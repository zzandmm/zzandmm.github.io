[{"title":"熬夜的一天","path":"/2025/03/21/15.2025.3.20熬夜的一天/","content":"摸鱼的一天 几乎啥也没干 好消息 某src赚了80 坏消息 hexo的专栏研究了两小时 凌晨一点多才折腾完 某人身上是有点玄学的 一凑过来 就想到了问题在哪里","categories":["记录生活"]},{"title":"创建专栏","path":"/2025/03/21/14.创建专栏/","content":"1.创建一个专栏在 blog/source/_data/ 文件夹中创建一个 topic 文件夹，在其中放入各个专栏的描述文件，文件名就是项目的 id： name值和id建议设置一样 1234name: Stellar # 在面包屑导航上会显示较短的名字title: Stellar - 每个人的独立博客 # 在列表页会显示完整的专栏标题description: 关于搭建独立博客相关的知识和经验分享，以及 Stellar 的高级用法、版本更新相关的注意事项。order_by: -date # 默认是按发布日期倒序排序 2. 发布文章在此专栏文章的 md 文件的 front-matter 部分指定所属的专栏 id （即上一步创建的文件名 id.yml） 12345678---title: 这是文章标题topic: id # 这是专栏id，对应 blog/source/_data/topic/id.yml---文章正文","categories":["hexo使用教程"]},{"title":"马克思主义基本原理","path":"/2025/03/20/13.马克思主义基本原理/","content":"1.导论导论1 什么是马克思马克思主义是由马克思和恩格斯创立并为后继者所不断发展的科学理论体系。 1.马克思主义基本原理是对马克思主义立场、观点、方法的集中概括，2.是马克思主义在其形成、发展和运用过程中经过反复检验而确立起来的具有普遍真理性的理论。3.它体现马克思主义的根本性质和整体特征，体现马克思主义科学性和革命性的统一。4.相对于特定历史条件下所做的个别理论判断和具体结论，马克思主义具有普遍的、根本的和长远的指导意义。 马克思主义的基本立场是马克思主义观察、分析和解决问题的根本立足和出发点。 马克思主义以无产阶级的解放和全人类的解放为己任，以人的自由全面发展为美好目标。 马克思的基本方法建立在辩证唯物主义和历史唯物主义的世界观和方法论基础上，指导我们正确认识世界和改造世界：实事求是的方法、辩证分析的方法、社会根本矛盾和主要矛盾分析的方法。 马克思主义的基本观点关于世界统一与物质、物质决定意识的观点关于事物矛盾运动规律的观点关于实践和认识辩证关系的观点关于社会存在决定社会意识的观点关于人与自然和谐共生的观点关于人类社会发展规律的观点关于世界历史的观点关于阶级和阶级斗争的观点关于人民群众创造历史的观点关于人的全面发展和社会全面进步的观点 关于商品经济和社会化大生产一般规律的观点关于劳动价值论、剩余价值论和资本主义生产方式的观点关于资本主义政治制度和意识形态本质的观点关于垄断资本主义的观点 关于社会主义必然代替资本主义的观点关于社会主义革命和无产阶级专政的观点关于社会主义社会本质特征和建设规律的观点关于共产主义社会基本特征和共产主义远大理想的观点 章节测验(多选题)马克思主义理论不可分割的三个主要组成部分是指（）。A、科学社会主义B、马克思主义哲学C、新自由主义D、马克思主义政治经济学 答案：ABD (多选题)马克思一生在理论上的两大发现包括（）。A、唯物史观B、唯心辩证法C、剩余价值学说D、空想社会主义 答案：AC (多选题)马克思主义的理论渊源主要有（）。A、英国古典政治经济学B、英国的不可知论思想C、德国古典哲学D、英法两国的空想社会主义 答案：ACD (判断题)马克思主义是指引人们创造美好生活的行动指南。 答案：对 (判断题)马克思主义以无产阶级的解放和全人类的解放为己任。 答案：对","categories":["大学课程"]},{"title":"burp爆破时间调整","path":"/2025/03/20/12.burp爆破时间调整/","content":"","categories":["burp的使用"]},{"title":"burp_HaE插件安装","path":"/2025/03/20/11.HaE插件安装/","content":"1.下载地址https://github.com/gh0stkey/HaE 2.插件添加Extender - Extensions - Add - Select File - Next 2.配置文件存放地址 Linux&#x2F;Mac用户的配置文件目录：~/.config/HaE/ Windows用户的配置文件目录：%USERPROFILE%/.config/HaE/ 3.检查配置文件内容(添加插件的时候报错了 检查发现rules内容是空的)Rules.ymlhttps://github.com/gh0stkey/HaE/blob/master/src/main/resources/rules/Rules.yml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296rules:- group: Fingerprint rule: - name: Shiro loaded: true f_regex: (=deleteMe|rememberMe=) s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: green scope: any header engine: dfa sensitive: true - name: JSON Web Token loaded: true f_regex: (eyJ[A-Za-z0-9_-]&#123;10,&#125;\\.[A-Za-z0-9._-]&#123;10,&#125;|eyJ[A-Za-z0-9_\\/+-]&#123;10,&#125;\\.[A-Za-z0-9._\\/+-]&#123;10,&#125;) s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: green scope: any engine: nfa sensitive: true - name: Swagger UI loaded: true f_regex: ((swagger-ui.html)|(\\&quot;swagger\\&quot;:)|(Swagger UI)|(swaggerUi)|(swaggerVersion)) s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: red scope: response body engine: dfa sensitive: false - name: Ueditor loaded: true f_regex: (ueditor\\.(config|all)\\.js) s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: green scope: response body engine: dfa sensitive: false - name: Druid loaded: true f_regex: (Druid Stat Index) s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: orange scope: response body engine: dfa sensitive: false- group: Maybe Vulnerability rule: - name: Java Deserialization loaded: true f_regex: (javax\\.faces\\.ViewState) s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: yellow scope: response body engine: dfa sensitive: false - name: Debug Logic Parameters loaded: true f_regex: ((access=)|(adm=)|(admin=)|(alter=)|(cfg=)|(clone=)|(config=)|(create=)|(dbg=)|(debug=)|(delete=)|(disable=)|(edit=)|(enable=)|(exec=)|(execute=)|(grant=)|(load=)|(make=)|(modify=)|(rename=)|(reset=)|(root=)|(shell=)|(test=)|(toggl=)) s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: cyan scope: request engine: dfa sensitive: false - name: URL As A Value loaded: true f_regex: (=(https?)(://|%3a%2f%2f)) s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: cyan scope: any engine: nfa sensitive: false - name: Upload Form loaded: true f_regex: (type\\=\\&quot;file\\&quot;) s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: yellow scope: response body engine: dfa sensitive: false - name: DoS Paramters loaded: true f_regex: ((size=)|(page=)|(num=)|(limit=)|(start=)|(end=)|(count=)) s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: cyan scope: request engine: dfa sensitive: false- group: Basic Information rule: - name: Email loaded: true f_regex: (([a-z0-9]+[_|\\.])*[a-z0-9]+@([a-z0-9]+[-|_|\\.])*[a-z0-9]+\\.((?!js|css|jpg|jpeg|png|ico)[a-z]&#123;2,5&#125;)) s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: yellow scope: response engine: nfa sensitive: false - name: Chinese IDCard loaded: true f_regex: &#x27;[^0-9]((\\d&#123;8&#125;(0\\d|10|11|12)([0-2]\\d|30|31)\\d&#123;3&#125;$)|(\\d&#123;6&#125;(18|19|20)\\d&#123;2&#125;(0[1-9]|10|11|12)([0-2]\\d|30|31)\\d&#123;3&#125;(\\d|X|x)))[^0-9]&#x27; s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: orange scope: response body engine: nfa sensitive: true - name: Chinese Mobile Number loaded: true f_regex: &#x27;[^\\w]((?:(?:\\+|00)86)?1(?:(?:3[\\d])|(?:4[5-79])|(?:5[0-35-9])|(?:6[5-7])|(?:7[0-8])|(?:8[\\d])|(?:9[189]))\\d&#123;8&#125;)[^\\w]&#x27; s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: orange scope: response body engine: nfa sensitive: false - name: Internal IP Address loaded: true f_regex: &#x27;[^0-9]((127\\.0\\.0\\.1)|(10\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;)|(172\\.((1[6-9])|(2\\d)|(3[01]))\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;)|(192\\.168\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;))&#x27; s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: cyan scope: response engine: nfa sensitive: true - name: MAC Address loaded: true f_regex: (^([a-fA-F0-9]&#123;2&#125;(:[a-fA-F0-9]&#123;2&#125;)&#123;5&#125;)|[^a-zA-Z0-9]([a-fA-F0-9]&#123;2&#125;(:[a-fA-F0-9]&#123;2&#125;)&#123;5&#125;)) s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: green scope: response engine: nfa sensitive: true- group: Sensitive Information rule: - name: Cloud Key loaded: true f_regex: (((access)(|-|_)(key)(|-|_)(id|secret))|(LTAI[a-z0-9]&#123;12,20&#125;)) s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: yellow scope: any engine: nfa sensitive: false - name: Windows File/Dir Path loaded: true f_regex: &#x27;[^\\w](([a-zA-Z]:\\\\(?:\\w+\\\\?)*)|([a-zA-Z]:\\\\(?:\\w+\\\\)*\\w+\\.\\w+))&#x27; s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: green scope: response engine: nfa sensitive: true - name: Password Field loaded: true f_regex: ((|&#x27;|&quot;)(|[\\w]&#123;1,10&#125;)([p](ass|wd|asswd|assword))(|[\\w]&#123;1,10&#125;)(|&#x27;|&quot;)(:|=)( |)(&#x27;|&quot;)(.*?)(&#x27;|&quot;)(|,)) s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: yellow scope: response body engine: nfa sensitive: false - name: Username Field loaded: true f_regex: ((|&#x27;|&quot;)(|[\\w]&#123;1,10&#125;)(([u](ser|name|sername))|(account)|((((create|update)((d|r)|(by|on|at)))|(creator))))(|[\\w]&#123;1,10&#125;)(|&#x27;|&quot;)(:|=)( |)(&#x27;|&quot;)(.*?)(&#x27;|&quot;)(|,)) s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: green scope: response body engine: nfa sensitive: false - name: WeCom Key loaded: true f_regex: ((corp)(id|secret)) s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: green scope: response body engine: dfa sensitive: false - name: JDBC Connection loaded: true f_regex: (jdbc:[a-z:]+://[a-z0-9\\.\\-_:;=/@?,&amp;]+) s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: yellow scope: any engine: nfa sensitive: false - name: Authorization Header loaded: true f_regex: ((basic [a-z0-9=:_\\+\\/-]&#123;5,100&#125;)|(bearer [a-z0-9_.=:_\\+\\/-]&#123;5,100&#125;)) s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: yellow scope: response body engine: nfa sensitive: false - name: Sensitive Field loaded: true f_regex: ((\\[)?(&#x27;|&quot;)?([\\w]&#123;0,10&#125;)((key)|(secret)|(token)|(config)|(auth)|(access)|(admin))([\\w]&#123;0,10&#125;)(&#x27;|&quot;)?(\\])?( |)(:|=)( |)(&#x27;|&quot;)(.*?)(&#x27;|&quot;)(|,)) s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: yellow scope: response engine: nfa sensitive: false- group: New 0 rule: - name: New Name loaded: false f_regex: (First Regex) s_regex: (Second Regex) format: &#x27;&#123;0&#125;&#x27; color: gray scope: any engine: nfa sensitive: false- group: Other rule: - name: Linkfinder loaded: true f_regex: (?:&quot;|&#x27;)(((?:[a-zA-Z]&#123;1,10&#125;://|//)[^&quot;&#x27;/]&#123;1,&#125;\\.[a-zA-Z]&#123;2,&#125;[^&quot;&#x27;]&#123;0,&#125;)|((?:/|\\.\\./|\\./)[^&quot;&#x27;&gt;&lt;,;|*()(%%$^/\\\\\\[\\]][^&quot;&#x27;&gt;&lt;,;|()]&#123;1,&#125;)|([a-zA-Z0-9_\\-/]&#123;1,&#125;/[a-zA-Z0-9_\\-/]&#123;1,&#125;\\.(?:[a-zA-Z]&#123;1,4&#125;|action)(?:[\\?|#][^&quot;|&#x27;]&#123;0,&#125;|))|([a-zA-Z0-9_\\-/]&#123;1,&#125;/[a-zA-Z0-9_\\-/]&#123;3,&#125;(?:[\\?|#][^&quot;|&#x27;]&#123;0,&#125;|))|([a-zA-Z0-9_\\-]&#123;1,&#125;\\.(?:\\w)(?:[\\?|#][^&quot;|&#x27;]&#123;0,&#125;|)))(?:&quot;|&#x27;) s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: gray scope: response body engine: nfa sensitive: true - name: Source Map loaded: true f_regex: (\\.js\\.map) s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: pink scope: response body engine: dfa sensitive: false - name: HTML Notes loaded: true f_regex: (&lt;!--.*?--&gt;) s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: magenta scope: response body engine: nfa sensitive: false - name: Create Script loaded: true f_regex: (\\+\\&#123;.*?\\&#125;\\[[a-zA-Z]\\]\\+&quot;.*?\\.js&quot;) s_regex: &#x27;&quot;?([\\w].*?)&quot;?:&quot;(.*?)&quot;&#x27; format: &#x27;&#123;0&#125;.&#123;1&#125;&#x27; color: green scope: response body engine: nfa sensitive: false - name: URL Schemes loaded: true f_regex: ((?![http]|[https])(([-A-Za-z0-9]&#123;1,20&#125;)://[-A-Za-z0-9+&amp;@#/%?=~_|!:,.;]+[-A-Za-z0-9+&amp;@#/%=~_|])) s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: yellow scope: response body engine: nfa sensitive: false - name: Router Push loaded: true f_regex: (\\$router\\.push) s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: magenta scope: response body engine: dfa sensitive: false - name: All URL loaded: true f_regex: (https?://[-A-Za-z0-9+&amp;@#/%?=~_|!:,.;\\u4E00-\\u9FFF]+[-A-Za-z0-9+&amp;@#/%=~_|]) s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: gray scope: response body engine: nfa sensitive: true Config.yml 123456excludeSuffix: 3g2|3gp|7z|aac|abw|aif|aifc|aiff|apk|arc|au|avi|azw|bat|bin|bmp|bz|bz2|cmd|cmx|cod|com|csh|css|csv|dll|doc|docx|ear|eot|epub|exe|flac|flv|gif|gz|ico|ics|ief|jar|jfif|jpe|jpeg|jpg|less|m3u|mid|midi|mjs|mkv|mov|mp2|mp3|mp4|mpa|mpe|mpeg|mpg|mpkg|mpp|mpv2|odp|ods|odt|oga|ogg|ogv|ogx|otf|pbm|pdf|pgm|png|pnm|ppm|ppt|pptx|ra|ram|rar|ras|rgb|rmi|rtf|scss|sh|snd|svg|swf|tar|tif|tiff|ttf|vsd|war|wav|weba|webm|webp|wmv|woff|woff2|xbm|xls|xlsx|xpm|xul|xwd|zipblockHost: gh0st.cnAIPrompt: |- You are a data security expert in the field of cyber security. Your task is to optimize the information provided by the user and then output it in JSON format. The user-supplied information is data that has been extracted by regular expressions. The user-supplied information is divided into two parts, the first part is RuleName which represents the name of the regular expression and the second part is MarkInfo which represents the data extracted by the regular expression. You need to find the matching or similar data in MarkInfo according to the meaning of RuleName, and output the original rows of these data in JSON format.(garbled and meaningless data rows should be removed) You must ensure that the extracted data is accurately expressed and correctly formatted in the JSON structure. Your output data must comply with the original MarkInfo content rows without modification, and strictly adhere to the following JSON format for return, no other text, code and formatting (e.g., line breaks, carriage returns, indentation, spaces), once the return of other irrelevant content will cause irreparable damage to the user: &#123;&quot;data&quot;:[&quot;data1&quot;, &quot;data2&quot;]&#125;.","categories":["burp的使用"]},{"title":"在burp中对字典进编码、解码","path":"/2025/03/20/10.在burp中对字典进编码解码/","content":"","categories":["burp的使用"]},{"title":"burp_并发插件","path":"/2025/03/20/9.burp_并发插件/","content":"1.插件安装下载 需要java环境 2.插件的使用抓到要并发的数据包右键发送到turbo intruder","categories":["burp的使用"]},{"title":"文章封面及横幅","path":"/2025/03/20/8.文章封面/","content":"1.文章封面填写 topic 与 headline 时大标题位于上方 只填写 headline 或填写 headline 与 caption 时大标题位于下方 123456789---cover: /assets/xaoxuu/blog/2020-0927a@1x.svg # 必选poster: # 海报（可选，全图封面卡片） topic: 标题上方的小字 # 可选 headline: 大标题 # 必选 caption: 标题下方的小字 # 可选 color: 标题颜色 # 可选，默认为跟随主题的动态颜色 # white,red...--- 2.横幅123---banner: /assets/xaoxuu/blog/2020-0927a@1x.svg---","categories":["hexo使用教程"]},{"title":"Creating an App Builder 2","path":"/2025/03/20/7.Builder2/","content":"在Creating an App Builder 1: Setup, layout and theme的基础上逐渐新增功能 1. 打包 Fyne 应用程序找一张png图片作为Icon 将 Fyne 应用程序打包在终端输入 1fyne package 查看打包的应用程序在终端输入 1open . 2.安装 Fyne 框架及其依赖项1fyne install 3.对 Fyne 应用程序进行配置新建FyneApp.toml文件FyneApp.toml 是 Fyne 应用程序的配置文件，通常用于定义应用程序的元数据和设置文件使用 TOML 格式，可以包含应用程序的名称、版本、图标路径等信息 将Icon移动到assets并在FyneApp.toml中输入 1234[Details] Icon = &quot;assets/Icon.png&quot; # 应用程序图标的路径 Name = &quot;My App&quot; # 应用程序的名称 ID = &quot;app.appbuilder&quot; # 应用程序的唯一标识符 终端输入命令，再次打包 1fyne package 终端输入命令 查看打包的程序 1open . 4.将 Fyne 应用程序打包为适用于 iOS 模拟器的可执行文件将 Fyne 应用程序打包为适用于 iOS 模拟器的可执行文件 拖入一张名为AppIcon.png图片作为app的图标 终端输入 1fyne package -os iossimulator 5.XCODE下载安装app store可以下载 下载好了之后需要添加账户，生成证书 IOS模拟器安装 安装完成之后可将 iOS 模拟器的可执行文件拖入iOS设备(图片建议是正方形的，非正方形会导致 可以用微信上传头像裁剪一下) 6.将 Fyne 应用程序打包为适用于 安卓 的可执行文件若要打包成安卓可执行文件（需要安装 Android NDK）输入以下命令，xxx替换成app的名称 1fyne package -os android -name xxxxxx -id com.example.xxxxxx 7.网页访问所写的程序终端输入 1fyne serve 终端输入http://localhost:8080/可访问 8.案例一：openProject方法 文件夹选择对话框openProject 方法用于打开一个文件夹选择对话框，允许用户选择一个目录 gui.go文件新增内容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package mainimport (\t&quot;image/color&quot;\t&quot;log&quot;\t&quot;fyne.io/fyne/v2&quot;\t&quot;fyne.io/fyne/v2/canvas&quot;\t&quot;fyne.io/fyne/v2/container&quot;\t&quot;fyne.io/fyne/v2/dialog&quot;\t&quot;fyne.io/fyne/v2/theme&quot;\t&quot;fyne.io/fyne/v2/widget&quot;)type gui struct &#123;\twin fyne.Window //// 定义一个窗口，类型为 fyne.Window&#125;func makeBanner() fyne.CanvasObject &#123;//新增内容 makeBanner makeBanner 创建一个横幅（Banner）区域，包含一个工具栏和一个图片。返回值为 fyne.CanvasObject 类型，可以直接作为 Fyne 的 UI 组件使用。\ttoolbor := widget.NewToolbar(// 创建工具栏 (Toolbar)，其中包含一个 Home 图标的按钮 widget.NewToolbarAction(theme.HomeIcon(), func() &#123;&#125;), // 点击按钮时，可以通过回调函数执行自定义逻辑（此处为空函数） )\tlogo := canvas.NewImageFromResource(resourceLogoPng)// 创建一个图片对象 (Image)，从资源文件中加载图片 resourceLogoPng 是通过 Fyne 的 bundle 工具生成的资源变量 logo.FillMode = canvas.ImageFillContain// 设置图片的填充模式为 ImageFillContain 这会保持图片的宽高比例并将其缩放到容器内。\treturn container.NewStack(toolbor, container.NewPadded(logo))// 将工具栏和图片叠加在一起，形成一个堆叠布局 (Stack Layout) &#125;//container.NewPadded 会将传入的组件（如 logo）包装在一个容器中，并为其四周添加均匀的内边距。这样可以使组件与周围的其他内容保持一定距离，从而提升视觉效果func (g *gui)makeGUI() fyne.CanvasObject &#123;//具有接收者 g *gui，这意味着它可以访问 gui 结构体中的其他字段和方法。\ttop := makeBanner()// 调用 makeBanner() 函数创建一个顶部区域的组件并赋值给变量 top。\tleft := widget.NewLabel(&quot;Left&quot;)// 创建一个标签（Label），显示 &quot;Left&quot;这个标签将被放置在窗口布局的左侧\tright := widget.NewLabel(&quot;Right&quot;)//标签将被放置在窗口布局的右侧\tcontent := canvas.NewRectangle(color.Gray&#123;Y: 0xee&#125;)// 创建一个灰色的矩形对象 color.Gray&#123;Y: 0xee&#125; 表示一种灰色，其中 Y 的值范围是 0x00（黑色）到 0xff（白色） dividers := [3]fyne.CanvasObject&#123; widget.NewSeparator(), widget.NewSeparator(), widget.NewSeparator(),// 定义分隔线数组，用于在布局中分隔不同部分\t&#125; objs := []fyne.CanvasObject&#123;content, top, left, right, dividers[0], dividers[1], dividers[2]&#125;// 定义CanvasObject 对象，用于传递给 container.New 内容区域(content)、顶部(top)、左侧(left)、右侧(right)，以及三个分隔线(dividers) return container.New(newFysionLayout(top, left, right, content, dividers), objs...)//修改// 使用 container.New 创建一个容器，并指定自定义布局管理器 newFysionLayout。&#125;// 第一个参数是自定义布局管理器，它负责定义子对象的排列方式。 第二个参数是 objs 切片，通过展开操作符 (objs...) 将所有子对象传递给容器。func (g *gui) openProject() &#123;// openProject 方法用于打开一个文件夹选择对话框，允许用户选择一个目录。\tdialog.ShowFolderOpen(func(dir fyne.ListableURI, err error) &#123;// 该回调函数在用户选择文件夹后被调用 这里可以添加处理用户选择的逻辑 dir: 用户选择的目录，类型为 fyne.ListableURI err: 如果选择过程中发生错误，将包含错误信息 log.Println(&quot;Dir opened&quot;, dir)// 记录打开的目录信息到日志 输出一条日志，内容为 &quot;Dir opened&quot; 和用户选择的目录 dir\t&#125;, g.win)&#125; main.go内容调整 12345678910111213141516171819package mainimport (\t&quot;fyne.io/fyne/v2/app&quot;)func main() &#123;\ta := app.New() a.Settings().SetTheme(newFysionTheme())//新增内容\tw := a.NewWindow(&quot;My application&quot;)// 创建一个新的窗口，并将窗口的标题设置为 &quot;My application&quot; 这个窗口是应用程序的主要界面，可以用来显示各种内容 w.SetPadded(false)// 设置窗口的填充属性为 false，表示不使用默认的边距 w.Resize(fyne.NewSize(1024, 768))//将窗口的尺寸调整为宽度 1024 像素，高度 768 像素 ui := &amp;gui&#123;win: w&#125; // 创建一个 gui 结构体实例，并将窗口对象传递给它\tw.SetContent(ui.makeGUI())// 设置窗口的内容为通过 ui.makeGUI() 创建的界面 ui.openProject()// 调用 openProject 方法以打开项目选择对话框\tw.ShowAndRun()// 显示窗口并进入应用程序的主事件循环&#125; 运行程序 9.案例二：在界面conent中动态更新目录信息gui.go内容调整 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package mainimport (\t&quot;image/color&quot;\t&quot;fyne.io/fyne/v2&quot;\t&quot;fyne.io/fyne/v2/canvas&quot;\t&quot;fyne.io/fyne/v2/container&quot;\t&quot;fyne.io/fyne/v2/dialog&quot;\t&quot;fyne.io/fyne/v2/theme&quot;\t&quot;fyne.io/fyne/v2/widget&quot;)type gui struct &#123;\twin fyne.Window // 定义一个窗口，类型为 fyne.Window\tdirectory *widget.Label// 用于显示当前选择的目录，类型为 *widget.Label，允许在界面中动态更新目录信息&#125;func makeBanner() fyne.CanvasObject &#123;//新增内容 makeBanner makeBanner 创建一个横幅（Banner）区域，包含一个工具栏和一个图片。返回值为 fyne.CanvasObject 类型，可以直接作为 Fyne 的 UI 组件使用。\ttoolbor := widget.NewToolbar(// 创建工具栏 (Toolbar)，其中包含一个 Home 图标的按钮 widget.NewToolbarAction(theme.HomeIcon(), func() &#123;&#125;), // 点击按钮时，可以通过回调函数执行自定义逻辑（此处为空函数） )\tlogo := canvas.NewImageFromResource(resourceLogoPng)// 创建一个图片对象 (Image)，从资源文件中加载图片 resourceLogoPng 是通过 Fyne 的 bundle 工具生成的资源变量 logo.FillMode = canvas.ImageFillContain// 设置图片的填充模式为 ImageFillContain 这会保持图片的宽高比例并将其缩放到容器内。\treturn container.NewStack(toolbor, container.NewPadded(logo))// 将工具栏和图片叠加在一起，形成一个堆叠布局 (Stack Layout) &#125;//container.NewPadded 会将传入的组件（如 logo）包装在一个容器中，并为其四周添加均匀的内边距。这样可以使组件与周围的其他内容保持一定距离，从而提升视觉效果func (g *gui)makeGUI() fyne.CanvasObject &#123;//具有接收者 g *gui，这意味着它可以访问 gui 结构体中的其他字段和方法。\ttop := makeBanner()// 调用 makeBanner() 函数创建一个顶部区域的组件并赋值给变量 top。\tleft := widget.NewLabel(&quot;Left&quot;)// 创建一个标签（Label），显示 &quot;Left&quot;这个标签将被放置在窗口布局的左侧\tright := widget.NewLabel(&quot;Right&quot;)//标签将被放置在窗口布局的右侧\tg.directory = widget.NewLabel(&quot;&quot;)// 创建一个新的标签，初始内容为空字符串，并将其赋值给 gui 结构体的 directory 字段\tcontent := container.NewStack(canvas.NewRectangle(color.Gray&#123;Y: 0xee&#125;), g.directory)// 创建一个新的堆叠容器，包含一个灰色矩形和目录标签 将之前创建的目录标签添加到堆叠容器中 dividers := [3]fyne.CanvasObject&#123; widget.NewSeparator(), widget.NewSeparator(), widget.NewSeparator(),// 定义分隔线数组，用于在布局中分隔不同部分\t&#125; objs := []fyne.CanvasObject&#123;content, top, left, right, dividers[0], dividers[1], dividers[2]&#125;// 定义CanvasObject 对象，用于传递给 container.New 内容区域(content)、顶部(top)、左侧(left)、右侧(right)，以及三个分隔线(dividers) return container.New(newFysionLayout(top, left, right, content, dividers), objs...)//修改// 使用 container.New 创建一个容器，并指定自定义布局管理器 newFysionLayout。&#125;// 第一个参数是自定义布局管理器，它负责定义子对象的排列方式。 第二个参数是 objs 切片，通过展开操作符 (objs...) 将所有子对象传递给容器。func (g *gui) openProject() &#123;// openProject 方法用于打开一个文件夹选择对话框，允许用户选择一个目录。\tdialog.ShowFolderOpen(func(dir fyne.ListableURI, err error) &#123;// 该回调函数在用户选择文件夹后被调用 这里可以添加处理用户选择的逻辑 dir: 用户选择的目录，类型为 fyne.ListableURI err: 如果选择过程中发生错误，将包含错误信息 if err != nil &#123; dialog.ShowError(err, g.win)// 检查是否发生错误 如果发生错误，显示错误对话框，并将错误信息和窗口传递给对话框 return &#125; if dir == nil &#123; return// 检查目录是否为 nil 如果目录为空，结束当前函数的执行 &#125; name := dir.Name()// 获取目录的名称 g.win.SetTitle(&quot;Fysion App: &quot; + name)// 设置窗口标题为 &quot;Fysion App: &quot; 加上目录名称 g.directory.SetText(name)// 更新显示的目录标签文本为目录名称\t&#125;, g.win)&#125; 运行程序 10.案例三：强制选择的对话框（不选择文件夹 无法关闭openfolder）gui.go内容修改 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package mainimport (\t&quot;image/color&quot;\t&quot;fyne.io/fyne/v2&quot;\t&quot;fyne.io/fyne/v2/canvas&quot;\t&quot;fyne.io/fyne/v2/container&quot;\t&quot;fyne.io/fyne/v2/dialog&quot;\t&quot;fyne.io/fyne/v2/theme&quot;\t&quot;fyne.io/fyne/v2/widget&quot;)type gui struct &#123;\twin fyne.Window // 定义一个窗口，类型为 fyne.Window\tdirectory *widget.Label// 用于显示当前选择的目录，类型为 *widget.Label，允许在界面中动态更新目录信息&#125;func makeBanner() fyne.CanvasObject &#123;//新增内容 makeBanner makeBanner 创建一个横幅（Banner）区域，包含一个工具栏和一个图片。返回值为 fyne.CanvasObject 类型，可以直接作为 Fyne 的 UI 组件使用。\ttoolbor := widget.NewToolbar(// 创建工具栏 (Toolbar)，其中包含一个 Home 图标的按钮 widget.NewToolbarAction(theme.HomeIcon(), func() &#123;&#125;), // 点击按钮时，可以通过回调函数执行自定义逻辑（此处为空函数） )\tlogo := canvas.NewImageFromResource(resourceLogoPng)// 创建一个图片对象 (Image)，从资源文件中加载图片 resourceLogoPng 是通过 Fyne 的 bundle 工具生成的资源变量 logo.FillMode = canvas.ImageFillContain// 设置图片的填充模式为 ImageFillContain 这会保持图片的宽高比例并将其缩放到容器内。\treturn container.NewStack(toolbor, container.NewPadded(logo))// 将工具栏和图片叠加在一起，形成一个堆叠布局 (Stack Layout) &#125;//container.NewPadded 会将传入的组件（如 logo）包装在一个容器中，并为其四周添加均匀的内边距。这样可以使组件与周围的其他内容保持一定距离，从而提升视觉效果func (g *gui)makeGUI() fyne.CanvasObject &#123;//具有接收者 g *gui，这意味着它可以访问 gui 结构体中的其他字段和方法。\ttop := makeBanner()// 调用 makeBanner() 函数创建一个顶部区域的组件并赋值给变量 top。\tleft := widget.NewLabel(&quot;Left&quot;)// 创建一个标签（Label），显示 &quot;Left&quot;这个标签将被放置在窗口布局的左侧\tright := widget.NewLabel(&quot;Right&quot;)//标签将被放置在窗口布局的右侧\tg.directory = widget.NewLabel(&quot;&quot;)// 创建一个新的标签，初始内容为空字符串，并将其赋值给 gui 结构体的 directory 字段\tcontent := container.NewStack(canvas.NewRectangle(color.Gray&#123;Y: 0xee&#125;), g.directory)// 创建一个新的堆叠容器，包含一个灰色矩形和目录标签 将之前创建的目录标签添加到堆叠容器中 dividers := [3]fyne.CanvasObject&#123; widget.NewSeparator(), widget.NewSeparator(), widget.NewSeparator(),// 定义分隔线数组，用于在布局中分隔不同部分\t&#125; objs := []fyne.CanvasObject&#123;content, top, left, right, dividers[0], dividers[1], dividers[2]&#125;// 定义CanvasObject 对象，用于传递给 container.New 内容区域(content)、顶部(top)、左侧(left)、右侧(right)，以及三个分隔线(dividers) return container.New(newFysionLayout(top, left, right, content, dividers), objs...)//修改// 使用 container.New 创建一个容器，并指定自定义布局管理器 newFysionLayout。&#125;// 第一个参数是自定义布局管理器，它负责定义子对象的排列方式。 第二个参数是 objs 切片，通过展开操作符 (objs...) 将所有子对象传递给容器。func (g *gui) openProject() &#123;// openProject 方法用于打开一个文件夹选择对话框，允许用户选择一个目录。\tdialog.ShowFolderOpen(func(dir fyne.ListableURI, err error) &#123;// 该回调函数在用户选择文件夹后被调用 这里可以添加处理用户选择的逻辑 dir: 用户选择的目录，类型为 fyne.ListableURI err: 如果选择过程中发生错误，将包含错误信息 if err != nil &#123; dialog.ShowError(err, g.win)// 检查是否发生错误 如果发生错误，显示错误对话框，并将错误信息和窗口传递给对话框 g.openProject()//打开openfolder return &#125; if dir == nil &#123; return// 检查目录是否为 nil 如果目录为空，结束当前函数的执行 &#125; name := dir.Name()// 获取目录的名称 g.win.SetTitle(&quot;Fysion App: &quot; + name)// 设置窗口标题为 &quot;Fysion App: &quot; 加上目录名称 g.directory.SetText(name)// 更新显示的目录标签文本为目录名称\t&#125;, g.win)&#125; 11.案例四：增加提示内容gui.go内容略作修改 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package mainimport (\t&quot;image/color&quot;\t&quot;fyne.io/fyne/v2&quot;\t&quot;fyne.io/fyne/v2/canvas&quot;\t&quot;fyne.io/fyne/v2/container&quot;\t&quot;fyne.io/fyne/v2/dialog&quot;\t&quot;fyne.io/fyne/v2/theme&quot;\t&quot;fyne.io/fyne/v2/widget&quot;)type gui struct &#123;\twin fyne.Window // 定义一个窗口，类型为 fyne.Window\tdirectory *widget.Label// 用于显示当前选择的目录，类型为 *widget.Label，允许在界面中动态更新目录信息&#125;func makeBanner() fyne.CanvasObject &#123;//新增内容 makeBanner makeBanner 创建一个横幅（Banner）区域，包含一个工具栏和一个图片。返回值为 fyne.CanvasObject 类型，可以直接作为 Fyne 的 UI 组件使用。\ttoolbor := widget.NewToolbar(// 创建工具栏 (Toolbar)，其中包含一个 Home 图标的按钮 widget.NewToolbarAction(theme.HomeIcon(), func() &#123;&#125;), // 点击按钮时，可以通过回调函数执行自定义逻辑（此处为空函数） )\tlogo := canvas.NewImageFromResource(resourceLogoPng)// 创建一个图片对象 (Image)，从资源文件中加载图片 resourceLogoPng 是通过 Fyne 的 bundle 工具生成的资源变量 logo.FillMode = canvas.ImageFillContain// 设置图片的填充模式为 ImageFillContain 这会保持图片的宽高比例并将其缩放到容器内。\treturn container.NewStack(toolbor, container.NewPadded(logo))// 将工具栏和图片叠加在一起，形成一个堆叠布局 (Stack Layout) &#125;//container.NewPadded 会将传入的组件（如 logo）包装在一个容器中，并为其四周添加均匀的内边距。这样可以使组件与周围的其他内容保持一定距离，从而提升视觉效果func (g *gui)makeGUI() fyne.CanvasObject &#123;//具有接收者 g *gui，这意味着它可以访问 gui 结构体中的其他字段和方法。\ttop := makeBanner()// 调用 makeBanner() 函数创建一个顶部区域的组件并赋值给变量 top。\tleft := widget.NewLabel(&quot;Left&quot;)// 创建一个标签（Label），显示 &quot;Left&quot;这个标签将被放置在窗口布局的左侧\tright := widget.NewLabel(&quot;Right&quot;)//标签将被放置在窗口布局的右侧\tg.directory = widget.NewLabel(&quot;Welcome to Fysion, open a folder... from the menu&quot;)// 创建一个新的标签，并将其赋值给 gui 结构体的 directory 字段\tcontent := container.NewStack(canvas.NewRectangle(color.Gray&#123;Y: 0xee&#125;), g.directory)// 创建一个新的堆叠容器，包含一个灰色矩形和目录标签 将之前创建的目录标签添加到堆叠容器中 dividers := [3]fyne.CanvasObject&#123; widget.NewSeparator(), widget.NewSeparator(), widget.NewSeparator(),// 定义分隔线数组，用于在布局中分隔不同部分\t&#125; objs := []fyne.CanvasObject&#123;content, top, left, right, dividers[0], dividers[1], dividers[2]&#125;// 定义CanvasObject 对象，用于传递给 container.New 内容区域(content)、顶部(top)、左侧(left)、右侧(right)，以及三个分隔线(dividers) return container.New(newFysionLayout(top, left, right, content, dividers), objs...)//修改// 使用 container.New 创建一个容器，并指定自定义布局管理器 newFysionLayout。&#125;// 第一个参数是自定义布局管理器，它负责定义子对象的排列方式。 第二个参数是 objs 切片，通过展开操作符 (objs...) 将所有子对象传递给容器。func (g *gui) openProject() &#123;// openProject 方法用于打开一个文件夹选择对话框，允许用户选择一个目录。\tdialog.ShowFolderOpen(func(dir fyne.ListableURI, err error) &#123;// 该回调函数在用户选择文件夹后被调用 这里可以添加处理用户选择的逻辑 dir: 用户选择的目录，类型为 fyne.ListableURI err: 如果选择过程中发生错误，将包含错误信息 if err != nil &#123; dialog.ShowError(err, g.win)// 检查是否发生错误 如果发生错误，显示错误对话框，并将错误信息和窗口传递给对话框 return &#125; if dir == nil &#123; return// 检查目录是否为 nil 如果目录为空，结束当前函数的执行 &#125; name := dir.Name()// 获取目录的名称 g.win.SetTitle(&quot;Fysion App: &quot; + name)// 设置窗口标题为 &quot;Fysion App: &quot; 加上目录名称 g.directory.SetText(name)// 更新显示的目录标签文本为目录名称\t&#125;, g.win)&#125; 运行程序 12.案例五：创建File菜单创建File菜单，可在File菜单中打开openflodermain.go新增内容 123456789101112131415161718192021222324252627282930package mainimport (\t&quot;fyne.io/fyne/v2/app&quot;)func main() &#123;\ta := app.New() a.Settings().SetTheme(newFysionTheme())//新增内容\tw := a.NewWindow(&quot;My application&quot;)// 创建一个新的窗口，并将窗口的标题设置为 &quot;My application&quot; 这个窗口是应用程序的主要界面，可以用来显示各种内容 w.SetPadded(false)// 设置窗口的填充属性为 false，表示不使用默认的边距 w.Resize(fyne.NewSize(1024, 768))//将窗口的尺寸调整为宽度 1024 像素，高度 768 像素 ui := &amp;gui&#123;win: w&#125; // 创建一个 gui 结构体实例，并将窗口对象传递给它\tw.SetContent(ui.makeGUI())// 设置窗口的内容为通过 ui.makeGUI() 创建的界面\tw.SetMainMenu(ui.makeMenu())// 将主菜单设置到窗口 w 中，ui 是一个包含 makeMenu 方法的结构体实例 ui.openProject()// 调用 openProject 方法以打开项目选择对话框\tw.ShowAndRun()// 显示窗口并进入应用程序的主事件循环 &#125;func (g *gui) makeMenu() *fyne.MainMenu &#123;// 定义一个名为 makeMenu 的方法，属于 gui 结构体，返回一个指向 fyne.MainMenu 的指针\tfile := fyne.NewMenu(&quot;File&quot;,// 创建一个名为 &quot;File&quot; 的菜单 fyne.NewMenuItem(&quot;Open Project&quot;, g.openProject),// 在 &quot;File&quot; 菜单中添加一个菜单项 &quot;Open Project&quot;，点击时调用 g.openProject 方法\t)\treturn fyne.NewMainMenu(file)// 返回一个新的主菜单，包含刚刚创建的 &quot;File&quot; 菜单&#125; 运行程序 13.案例六：窗口标题显示文件名称main.go新增内容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package main import ( &quot;flag&quot; &quot;fmt&quot; &quot;fyne.io/fyne/v2&quot; &quot;fyne.io/fyne/v2/app&quot; &quot;fyne.io/fyne/v2/storage&quot; )func main() &#123;\ta := app.New() a.Settings().SetTheme(newFysionTheme())//新增内容\tw := a.NewWindow(&quot;My application&quot;)// 创建一个新的窗口，并将窗口的标题设置为 &quot;My application&quot; 这个窗口是应用程序的主要界面，可以用来显示各种内容 w.SetPadded(false)// 设置窗口的填充属性为 false，表示不使用默认的边距 w.Resize(fyne.NewSize(1024, 768))//将窗口的尺寸调整为宽度 1024 像素，高度 768 像素 ui := &amp;gui&#123;win: w&#125; // 创建一个 gui 结构体实例，并将窗口对象传递给它\tw.SetContent(ui.makeGUI())// 设置窗口的内容为通过 ui.makeGUI() 创建的界面\tw.SetMainMenu(ui.makeMenu())// 将主菜单设置到窗口 w 中，ui 是一个包含 makeMenu 方法的结构体实例\tflag.Usage = func() &#123;// 设置 flag.Usage 函数，定义如何显示程序的使用说明 fmt.Println(&quot;Usage: fysion [project directory]&quot;)// 打印使用说明，提示用户输入项目目录\t&#125;\tflag.Parse()// 解析命令行参数\tif len(flag.Args()) &gt; 0 &#123;// 检查命令行参数的数量 dirPath := flag.Args()[0]// 获取第一个命令行参数，作为项目目录路径 dirURL := storage.NewFileURI(dirPath) // 创建一个新的文件 URI dir, err := storage.ListerForURI(dirURL)// 使用 ListerForURI 函数获取目录的列表器 if err != nil &#123; fmt.Println(&quot;Error opening project&quot;, err)// 如果发生错误，打印错误信息并返回 return &#125; else &#123; ui.openProject(dir) // 如果没有错误，调用 ui.openProject 方法打开项目 &#125; ui.openProjectDialog()// 打开项目对话框\t&#125;\tw.ShowAndRun()// 显示窗口并进入应用程序的主事件循环 &#125;func (g *gui) makeMenu() *fyne.MainMenu &#123;// 定义一个名为 makeMenu 的方法，属于 gui 结构体，返回一个指向 fyne.MainMenu 的指针\tfile := fyne.NewMenu(&quot;File&quot;,// 创建一个名为 &quot;File&quot; 的菜单 fyne.NewMenuItem(&quot;Open Project&quot;, g.openProjectDialog),// 在 &quot;File&quot; 菜单中添加一个菜单项 &quot;Open Project&quot;，点击时调用 g.openProjectDialog方法\t)\treturn fyne.NewMainMenu(file)// 返回一个新的主菜单，包含刚刚创建的 &quot;File&quot; 菜单&#125; gui.go文件修改 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package mainimport (\t&quot;image/color&quot;\t&quot;fyne.io/fyne/v2&quot;\t&quot;fyne.io/fyne/v2/canvas&quot;\t&quot;fyne.io/fyne/v2/container&quot;\t&quot;fyne.io/fyne/v2/dialog&quot;\t&quot;fyne.io/fyne/v2/theme&quot;\t&quot;fyne.io/fyne/v2/widget&quot;)type gui struct &#123;\twin fyne.Window // 定义一个窗口，类型为 fyne.Window\tdirectory *widget.Label// 用于显示当前选择的目录，类型为 *widget.Label，允许在界面中动态更新目录信息&#125;func makeBanner() fyne.CanvasObject &#123;//新增内容 makeBanner makeBanner 创建一个横幅（Banner）区域，包含一个工具栏和一个图片。返回值为 fyne.CanvasObject 类型，可以直接作为 Fyne 的 UI 组件使用。\ttoolbor := widget.NewToolbar(// 创建工具栏 (Toolbar)，其中包含一个 Home 图标的按钮 widget.NewToolbarAction(theme.HomeIcon(), func() &#123;&#125;), // 点击按钮时，可以通过回调函数执行自定义逻辑（此处为空函数） )\tlogo := canvas.NewImageFromResource(resourceLogoPng)// 创建一个图片对象 (Image)，从资源文件中加载图片 resourceLogoPng 是通过 Fyne 的 bundle 工具生成的资源变量 logo.FillMode = canvas.ImageFillContain// 设置图片的填充模式为 ImageFillContain 这会保持图片的宽高比例并将其缩放到容器内。\treturn container.NewStack(toolbor, container.NewPadded(logo))// 将工具栏和图片叠加在一起，形成一个堆叠布局 (Stack Layout) &#125;//container.NewPadded 会将传入的组件（如 logo）包装在一个容器中，并为其四周添加均匀的内边距。这样可以使组件与周围的其他内容保持一定距离，从而提升视觉效果func (g *gui)makeGUI() fyne.CanvasObject &#123;//具有接收者 g *gui，这意味着它可以访问 gui 结构体中的其他字段和方法。\ttop := makeBanner()// 调用 makeBanner() 函数创建一个顶部区域的组件并赋值给变量 top。\tleft := widget.NewLabel(&quot;Left&quot;)// 创建一个标签（Label），显示 &quot;Left&quot;这个标签将被放置在窗口布局的左侧\tright := widget.NewLabel(&quot;Right&quot;)//标签将被放置在窗口布局的右侧\tg.directory = widget.NewLabel(&quot;Welcome to Fysion, open a folder... from the menu&quot;)// 创建一个新的标签，并将其赋值给 gui 结构体的 directory 字段\tcontent := container.NewStack(canvas.NewRectangle(color.Gray&#123;Y: 0xee&#125;), g.directory)// 创建一个新的堆叠容器，包含一个灰色矩形和目录标签 将之前创建的目录标签添加到堆叠容器中 dividers := [3]fyne.CanvasObject&#123; widget.NewSeparator(), widget.NewSeparator(), widget.NewSeparator(),// 定义分隔线数组，用于在布局中分隔不同部分\t&#125; objs := []fyne.CanvasObject&#123;content, top, left, right, dividers[0], dividers[1], dividers[2]&#125;// 定义CanvasObject 对象，用于传递给 container.New 内容区域(content)、顶部(top)、左侧(left)、右侧(right)，以及三个分隔线(dividers) return container.New(newFysionLayout(top, left, right, content, dividers), objs...)//修改// 使用 container.New 创建一个容器，并指定自定义布局管理器 newFysionLayout。&#125;// 第一个参数是自定义布局管理器，它负责定义子对象的排列方式。 第二个参数是 objs 切片，通过展开操作符 (objs...) 将所有子对象传递给容器。func (g *gui) openProjectDialog() &#123;// openProjectDialog 方法属于 gui 结构体，用于打开一个文件夹选择对话框\tdialog.ShowFolderOpen(func(dir fyne.ListableURI, err error) &#123;// 该回调函数在用户选择文件夹后被调用 这里可以添加处理用户选择的逻辑 dir: 用户选择的目录，类型为 fyne.ListableURI err: 如果选择过程中发生错误，将包含错误信息 if err != nil &#123; dialog.ShowError(err, g.win)// 检查是否发生错误 如果发生错误，显示错误对话框，并将错误信息和窗口传递给对话框 return &#125; if dir == nil &#123; return// 检查目录是否为 nil 如果目录为空，结束当前函数的执行 &#125; g.openProject(dir)// 调用 openProject 方法，传入用户选择的目录\t&#125;, g.win)&#125;func (g *gui) openProject(dir fyne.ListableURI) &#123;// openProject 方法属于 gui 结构体，接收一个 ListableURI 类型的参数 dir\tname := dir.Name()// 获取目录的名称\tg.win.SetTitle(&quot;Fysion App: &quot; + name)// 设置窗口的标题，格式为 &quot;Fysion App: 项目名称&quot;\tg.directory.SetText(name)// 更新界面上显示的目录名称&#125; 运行程序.: 第一个点表示当前目录，Go 工具会在当前目录中查找 main 包并运行它。.: 第二个点也表示当前目录，作为命令行参数传递给程序。 1go run . . 14.案例七：取消自动打开foldermain.go文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package main import ( &quot;flag&quot; &quot;fmt&quot; &quot;fyne.io/fyne/v2&quot; &quot;fyne.io/fyne/v2/app&quot; &quot;fyne.io/fyne/v2/storage&quot; )func main() &#123;\ta := app.New() a.Settings().SetTheme(newFysionTheme())//新增内容\tw := a.NewWindow(&quot;My application&quot;)// 创建一个新的窗口，并将窗口的标题设置为 &quot;My application&quot; 这个窗口是应用程序的主要界面，可以用来显示各种内容 w.SetPadded(false)// 设置窗口的填充属性为 false，表示不使用默认的边距 w.Resize(fyne.NewSize(1024, 768))//将窗口的尺寸调整为宽度 1024 像素，高度 768 像素 ui := &amp;gui&#123;win: w&#125; // 创建一个 gui 结构体实例，并将窗口对象传递给它\tw.SetContent(ui.makeGUI())// 设置窗口的内容为通过 ui.makeGUI() 创建的界面\tw.SetMainMenu(ui.makeMenu())// 将主菜单设置到窗口 w 中，ui 是一个包含 makeMenu 方法的结构体实例\tflag.Usage = func() &#123;// 设置 flag.Usage 函数，定义如何显示程序的使用说明 fmt.Println(&quot;Usage: fysion [project directory]&quot;)// 打印使用说明，提示用户输入项目目录\t&#125;\tflag.Parse()// 解析命令行参数\tif len(flag.Args()) &gt; 0 &#123;// 检查命令行参数的数量 dirPath := flag.Args()[0]// 获取第一个命令行参数，作为项目目录路径 dirPath, err := filepath.Abs(dirPath)// 将 dirPath 转换为绝对路径 if err != nil &#123; fmt.Println(&quot;Error resolving project path&quot;, err)// 如果解析路径时发生错误，打印错误信息并终止程序 return &#125; dirURI := storage.NewFileURI(dirPath) // 创建一个新的文件 URI dir, err := storage.ListerForURI(dirURI)// 使用 ListerForURI 函数获取目录的列表器 if err != nil &#123; fmt.Println(&quot;Error opening project&quot;, err)// 如果发生错误，打印错误信息并返回 return &#125; ui.openProject(dir) &#125;else &#123; ui.openProjectDialog() &#125;\tw.ShowAndRun()// 显示窗口并进入应用程序的主事件循环&#125;func (g *gui) makeMenu() *fyne.MainMenu &#123;// 定义一个名为 makeMenu 的方法，属于 gui 结构体，返回一个指向 fyne.MainMenu 的指针\tfile := fyne.NewMenu(&quot;File&quot;,// 创建一个名为 &quot;File&quot; 的菜单 fyne.NewMenuItem(&quot;Open Project&quot;, g.openProjectDialog),// 在 &quot;File&quot; 菜单中添加一个菜单项 &quot;Open Project&quot;，点击时调用 g.openProjectDialog方法\t)\treturn fyne.NewMainMenu(file)// 返回一个新的主菜单，包含刚刚创建的 &quot;File&quot; 菜单&#125; 运行程序 1go run . . 15.案例八：标签内容自动更新gui.go内容修改 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package mainimport (\t&quot;image/color&quot;\t&quot;fyne.io/fyne/v2&quot;\t&quot;fyne.io/fyne/v2/canvas&quot;\t&quot;fyne.io/fyne/v2/container&quot;\t&quot;fyne.io/fyne/v2/data/binding&quot;\t&quot;fyne.io/fyne/v2/dialog&quot;\t&quot;fyne.io/fyne/v2/theme&quot;\t&quot;fyne.io/fyne/v2/widget&quot;)type gui struct &#123;\twin fyne.Window // 定义一个窗口，类型为 fyne.Window\ttitle binding.String//一个字符串类型的绑定对象&#125;func makeBanner() fyne.CanvasObject &#123;//新增内容 makeBanner makeBanner 创建一个横幅（Banner）区域，包含一个工具栏和一个图片。返回值为 fyne.CanvasObject 类型，可以直接作为 Fyne 的 UI 组件使用。\ttoolbor := widget.NewToolbar(// 创建工具栏 (Toolbar)，其中包含一个 Home 图标的按钮 widget.NewToolbarAction(theme.HomeIcon(), func() &#123;&#125;), // 点击按钮时，可以通过回调函数执行自定义逻辑（此处为空函数） )\tlogo := canvas.NewImageFromResource(resourceLogoPng)// 创建一个图片对象 (Image)，从资源文件中加载图片 resourceLogoPng 是通过 Fyne 的 bundle 工具生成的资源变量 logo.FillMode = canvas.ImageFillContain// 设置图片的填充模式为 ImageFillContain 这会保持图片的宽高比例并将其缩放到容器内。\treturn container.NewStack(toolbor, container.NewPadded(logo))// 将工具栏和图片叠加在一起，形成一个堆叠布局 (Stack Layout) &#125;//container.NewPadded 会将传入的组件（如 logo）包装在一个容器中，并为其四周添加均匀的内边距。这样可以使组件与周围的其他内容保持一定距离，从而提升视觉效果func (g *gui)makeGUI() fyne.CanvasObject &#123;//具有接收者 g *gui，这意味着它可以访问 gui 结构体中的其他字段和方法。\ttop := makeBanner()// 调用 makeBanner() 函数创建一个顶部区域的组件并赋值给变量 top。\tleft := widget.NewLabel(&quot;Left&quot;)// 创建一个标签（Label），显示 &quot;Left&quot;这个标签将被放置在窗口布局的左侧\tright := widget.NewLabel(&quot;Right&quot;)//标签将被放置在窗口布局的右侧\tdirectory := widget.NewLabelWithData(g.title)// 创建一个标签组件，并将其内容与 g.title 绑定。标签会动态显示 g.title 的值，当 g.title 更新时，标签内容会自动更新。\tcontent := container.NewStack(canvas.NewRectangle(color.Gray&#123;Y: 0xee&#125;), directory) dividers := [3]fyne.CanvasObject&#123; widget.NewSeparator(), widget.NewSeparator(), widget.NewSeparator(),// 定义分隔线数组，用于在布局中分隔不同部分\t&#125; objs := []fyne.CanvasObject&#123;content, top, left, right, dividers[0], dividers[1], dividers[2]&#125;// 定义CanvasObject 对象，用于传递给 container.New 内容区域(content)、顶部(top)、左侧(left)、右侧(right)，以及三个分隔线(dividers) return container.New(newFysionLayout(top, left, right, content, dividers), objs...)//修改// 使用 container.New 创建一个容器，并指定自定义布局管理器 newFysionLayout。&#125;// 第一个参数是自定义布局管理器，它负责定义子对象的排列方式。 第二个参数是 objs 切片，通过展开操作符 (objs...) 将所有子对象传递给容器。func (g *gui) openProjectDialog() &#123;// openProjectDialog 方法属于 gui 结构体，用于打开一个文件夹选择对话框\tdialog.ShowFolderOpen(func(dir fyne.ListableURI, err error) &#123;// 该回调函数在用户选择文件夹后被调用 这里可以添加处理用户选择的逻辑 dir: 用户选择的目录，类型为 fyne.ListableURI err: 如果选择过程中发生错误，将包含错误信息 if err != nil &#123; dialog.ShowError(err, g.win)// 检查是否发生错误 如果发生错误，显示错误对话框，并将错误信息和窗口传递给对话框 return &#125; if dir == nil &#123; return// 检查目录是否为 nil 如果目录为空，结束当前函数的执行 &#125; g.openProject(dir)// 调用 openProject 方法，传入用户选择的目录\t&#125;, g.win)&#125;func (g *gui) openProject(dir fyne.ListableURI) &#123;// openProject 方法属于 gui 结构体，接收一个 ListableURI 类型的参数 dir\tname := dir.Name()// 获取目录的名称\tg.win.SetTitle(&quot;Fysion App: &quot; + name)// 设置窗口的标题，格式为 &quot;Fysion App: 项目名称&quot;\tg.title.Set(name)// 将字符串变量 name 的值设置为绑定对象 g.title 的新值。 g.title 是一个 binding.String 类型的绑定对象，&#125;// 它与界面组件（如标签）绑定，值的变化会自动更新界面显示内容。 main.go内容修改 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package main import (\t&quot;flag&quot;\t&quot;fmt&quot;\t&quot;path/filepath&quot;\t&quot;fyne.io/fyne/v2&quot;\t&quot;fyne.io/fyne/v2/app&quot;\t&quot;fyne.io/fyne/v2/data/binding&quot;\t&quot;fyne.io/fyne/v2/storage&quot; )func main() &#123;\ta := app.New() a.Settings().SetTheme(newFysionTheme())//新增内容\tw := a.NewWindow(&quot;My application&quot;)// 创建一个新的窗口，并将窗口的标题设置为 &quot;My application&quot; 这个窗口是应用程序的主要界面，可以用来显示各种内容 w.SetPadded(false)// 设置窗口的填充属性为 false，表示不使用默认的边距 w.Resize(fyne.NewSize(1024, 768))//将窗口的尺寸调整为宽度 1024 像素，高度 768 像素\tui := &amp;gui&#123;win: w, title: binding.NewString()&#125;// 将窗口对象 w 赋值给 gui 的 win 字段 初始化 title 字段为一个可绑定的字符串对象。\tw.SetContent(ui.makeGUI())// 设置窗口的内容为通过 ui.makeGUI() 创建的界面\tw.SetMainMenu(ui.makeMenu())// 将主菜单设置到窗口 w 中，ui 是一个包含 makeMenu 方法的结构体实例\tflag.Usage = func() &#123;// 设置 flag.Usage 函数，定义如何显示程序的使用说明 fmt.Println(&quot;Usage: fysion [project directory]&quot;)// 打印使用说明，提示用户输入项目目录\t&#125;\tflag.Parse()// 解析命令行参数\tif len(flag.Args()) &gt; 0 &#123;// 检查命令行参数的数量 dirPath := flag.Args()[0]// 获取第一个命令行参数，作为项目目录路径 dirPath, err := filepath.Abs(dirPath)// 将 dirPath 转换为绝对路径 if err != nil &#123; fmt.Println(&quot;Error resolving project path&quot;, err)// 如果解析路径时发生错误，打印错误信息并终止程序 return &#125; dirURI := storage.NewFileURI(dirPath) // 创建一个新的文件 URI dir, err := storage.ListerForURI(dirURI)// 使用 ListerForURI 函数获取目录的列表器 if err != nil &#123; fmt.Println(&quot;Error opening project&quot;, err)// 如果发生错误，打印错误信息并返回 return &#125; ui.openProject(dir) &#125;else &#123; ui.openProjectDialog() // 调用 openProjectDialog 方法，弹出一个对话框让用户选择项目目录。 &#125;\tw.ShowAndRun()// 显示窗口并进入应用程序的主事件循环&#125;func (g *gui) makeMenu() *fyne.MainMenu &#123;// 定义一个名为 makeMenu 的方法，属于 gui 结构体，返回一个指向 fyne.MainMenu 的指针\tfile := fyne.NewMenu(&quot;File&quot;,// 创建一个名为 &quot;File&quot; 的菜单 fyne.NewMenuItem(&quot;Open Project&quot;, g.openProjectDialog),// 在 &quot;File&quot; 菜单中添加一个菜单项 &quot;Open Project&quot;，点击时调用 g.openProjectDialog方法\t)\treturn fyne.NewMainMenu(file)// 返回一个新的主菜单，包含刚刚创建的 &quot;File&quot; 菜单&#125; 运行程序 1go run . . 16.案例九：为绑定对象 ui.title 添加一个监听器（DataListener）gui.go内容调整 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package mainimport (\t&quot;image/color&quot;\t&quot;fyne.io/fyne/v2&quot;\t&quot;fyne.io/fyne/v2/canvas&quot;\t&quot;fyne.io/fyne/v2/container&quot;\t&quot;fyne.io/fyne/v2/data/binding&quot;\t&quot;fyne.io/fyne/v2/dialog&quot;\t&quot;fyne.io/fyne/v2/theme&quot;\t&quot;fyne.io/fyne/v2/widget&quot;)type gui struct &#123;\twin fyne.Window // 定义一个窗口，类型为 fyne.Window\ttitle binding.String//一个字符串类型的绑定对象&#125;func makeBanner() fyne.CanvasObject &#123;//新增内容 makeBanner makeBanner 创建一个横幅（Banner）区域，包含一个工具栏和一个图片。返回值为 fyne.CanvasObject 类型，可以直接作为 Fyne 的 UI 组件使用。\ttoolbor := widget.NewToolbar(// 创建工具栏 (Toolbar)，其中包含一个 Home 图标的按钮 widget.NewToolbarAction(theme.HomeIcon(), func() &#123;&#125;), // 点击按钮时，可以通过回调函数执行自定义逻辑（此处为空函数） )\tlogo := canvas.NewImageFromResource(resourceLogoPng)// 创建一个图片对象 (Image)，从资源文件中加载图片 resourceLogoPng 是通过 Fyne 的 bundle 工具生成的资源变量 logo.FillMode = canvas.ImageFillContain// 设置图片的填充模式为 ImageFillContain 这会保持图片的宽高比例并将其缩放到容器内。\treturn container.NewStack(toolbor, container.NewPadded(logo))// 将工具栏和图片叠加在一起，形成一个堆叠布局 (Stack Layout) &#125;//container.NewPadded 会将传入的组件（如 logo）包装在一个容器中，并为其四周添加均匀的内边距。这样可以使组件与周围的其他内容保持一定距离，从而提升视觉效果func (g *gui)makeGUI() fyne.CanvasObject &#123;//具有接收者 g *gui，这意味着它可以访问 gui 结构体中的其他字段和方法。\ttop := makeBanner()// 调用 makeBanner() 函数创建一个顶部区域的组件并赋值给变量 top。\tleft := widget.NewLabel(&quot;Left&quot;)// 创建一个标签（Label），显示 &quot;Left&quot;这个标签将被放置在窗口布局的左侧\tright := widget.NewLabel(&quot;Right&quot;)//标签将被放置在窗口布局的右侧\tdirectory := widget.NewLabelWithData(g.title)// 创建一个标签组件，并将其内容与 g.title 绑定。标签会动态显示 g.title 的值，当 g.title 更新时，标签内容会自动更新。\tcontent := container.NewStack(canvas.NewRectangle(color.Gray&#123;Y: 0xee&#125;), directory) dividers := [3]fyne.CanvasObject&#123; widget.NewSeparator(), widget.NewSeparator(), widget.NewSeparator(),// 定义分隔线数组，用于在布局中分隔不同部分\t&#125; objs := []fyne.CanvasObject&#123;content, top, left, right, dividers[0], dividers[1], dividers[2]&#125;// 定义CanvasObject 对象，用于传递给 container.New 内容区域(content)、顶部(top)、左侧(left)、右侧(right)，以及三个分隔线(dividers) return container.New(newFysionLayout(top, left, right, content, dividers), objs...)//修改// 使用 container.New 创建一个容器，并指定自定义布局管理器 newFysionLayout。&#125;// 第一个参数是自定义布局管理器，它负责定义子对象的排列方式。 第二个参数是 objs 切片，通过展开操作符 (objs...) 将所有子对象传递给容器。func (g *gui) makeMenu() *fyne.MainMenu &#123;// 定义一个名为 makeMenu 的方法，属于 gui 结构体，返回一个指向 fyne.MainMenu 的指针\tfile := fyne.NewMenu(&quot;File&quot;,// 创建一个名为 &quot;File&quot; 的菜单 fyne.NewMenuItem(&quot;Open Project&quot;, g.openProjectDialog),// 在 &quot;File&quot; 菜单中添加一个菜单项 &quot;Open Project&quot;，点击时调用 g.openProjectDialog方法\t)\treturn fyne.NewMainMenu(file)// 返回一个新的主菜单，包含刚刚创建的 &quot;File&quot; 菜单&#125;func (g *gui) openProjectDialog() &#123;// openProjectDialog 方法属于 gui 结构体，用于打开一个文件夹选择对话框\tdialog.ShowFolderOpen(func(dir fyne.ListableURI, err error) &#123;// 该回调函数在用户选择文件夹后被调用 这里可以添加处理用户选择的逻辑 dir: 用户选择的目录，类型为 fyne.ListableURI err: 如果选择过程中发生错误，将包含错误信息 if err != nil &#123; dialog.ShowError(err, g.win)// 检查是否发生错误 如果发生错误，显示错误对话框，并将错误信息和窗口传递给对话框 return &#125; if dir == nil &#123; return// 检查目录是否为 nil 如果目录为空，结束当前函数的执行 &#125; g.openProject(dir)// 调用 openProject 方法，传入用户选择的目录\t&#125;, g.win)&#125;func (g *gui) openProject(dir fyne.ListableURI) &#123;// openProject 方法属于 gui 结构体，接收一个 ListableURI 类型的参数 dir\tname := dir.Name()// 获取目录的名称\tg.title.Set(name)// 将字符串变量 name 的值设置为绑定对象 g.title 的新值。 g.title 是一个 binding.String 类型的绑定对象，&#125;// 它与界面组件（如标签）绑定，值的变化会自动更新界面显示内容。 main.go新增内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package main import (\t&quot;flag&quot;\t&quot;fmt&quot;\t&quot;path/filepath&quot;\t&quot;fyne.io/fyne/v2&quot;\t&quot;fyne.io/fyne/v2/app&quot;\t&quot;fyne.io/fyne/v2/data/binding&quot;\t&quot;fyne.io/fyne/v2/storage&quot; )func main() &#123;\ta := app.New() a.Settings().SetTheme(newFysionTheme())//新增内容\tw := a.NewWindow(&quot;My application&quot;)// 创建一个新的窗口，并将窗口的标题设置为 &quot;My application&quot; 这个窗口是应用程序的主要界面，可以用来显示各种内容 w.SetPadded(false)// 设置窗口的填充属性为 false，表示不使用默认的边距 w.Resize(fyne.NewSize(1024, 768))//将窗口的尺寸调整为宽度 1024 像素，高度 768 像素\tui := &amp;gui&#123;win: w, title: binding.NewString()&#125;// 将窗口对象 w 赋值给 gui 的 win 字段 初始化 title 字段为一个可绑定的字符串对象。\tw.SetContent(ui.makeGUI())// 设置窗口的内容为通过 ui.makeGUI() 创建的界面\tw.SetMainMenu(ui.makeMenu())// 将主菜单设置到窗口 w 中，ui 是一个包含 makeMenu 方法的结构体实例\tui.title.AddListener(binding.NewDataListener(func() &#123;// 为绑定对象 ui.title 添加一个监听器（DataListener） 当 ui.title 的值发生变化时，监听器会被触发，执行以下回调函数： name, _ := ui.title.Get() // 获取绑定对象 ui.title 的当前值。 w.SetTitle(&quot;Fysion App: &quot; + name) // 将窗口标题设置为 &quot;Fysion App: &quot; 加上绑定对象的值。\t&#125;))\tflag.Usage = func() &#123;// 设置 flag.Usage 函数，定义如何显示程序的使用说明 fmt.Println(&quot;Usage: fysion [project directory]&quot;)// 打印使用说明，提示用户输入项目目录\t&#125;\tflag.Parse()// 解析命令行参数\tif len(flag.Args()) &gt; 0 &#123;// 检查命令行参数的数量 dirPath := flag.Args()[0]// 获取第一个命令行参数，作为项目目录路径 dirPath, err := filepath.Abs(dirPath)// 将 dirPath 转换为绝对路径 if err != nil &#123; fmt.Println(&quot;Error resolving project path&quot;, err)// 如果解析路径时发生错误，打印错误信息并终止程序 return &#125; dirURI := storage.NewFileURI(dirPath) // 创建一个新的文件 URI dir, err := storage.ListerForURI(dirURI)// 使用 ListerForURI 函数获取目录的列表器 if err != nil &#123; fmt.Println(&quot;Error opening project&quot;, err)// 如果发生错误，打印错误信息并返回 return &#125; ui.openProject(dir) &#125;else &#123; ui.openProjectDialog() // 调用 openProjectDialog 方法，弹出一个对话框让用户选择项目目录。 &#125;\tw.ShowAndRun()// 显示窗口并进入应用程序的主事件循环&#125;","categories":["AppBuilder"]},{"title":"生活的小插曲-钥匙","path":"/2025/03/20/6.2025.3.20某人忘带钥匙/","content":"嘿，昨天，也就是周三 吃完饭，躺了一小会儿，计划逛盒马 结果怎么着，有人下楼，忘记带电瓶车钥匙 怎么办嘞，只能回去拿咯 嘿，这不是结束，而是开始 回去拿钥匙，顺便把忘带的垃圾带下来，还挺好的 当某人丢完垃圾，走向我的时候 某人笑着和我说，他忘带钥匙了 我以为他在开玩笑，没想到是真的， 某人再次回去 我心想这次总能带对吧 等呀等 终于某人带着钥匙下来 看着他的笑容，我总觉得不对劲 我试探的问，你拿的 该不会是我的钥匙吧 果然，还真的是我的钥匙 某人笑着递给我 又回去拿自己的 这一次，总算是拿对了 真的是好气又好笑","categories":["记录生活"]},{"title":"Creating an App Builder 1","path":"/2025/03/19/5.Builder1/","content":"1. 创建AppBuilder文件创建AppBuilder文件夹用于存放相关文件 我的AppBuilder所在位置 2.初始化go模块在终端，初始化一个 Go 模块，并创建一个名为 go.mod 的文件 （go.mod是运行后是自动生成的） 1go mod init appbuilder.app 3.将模块添加至项目将fyne.io&#x2F;fyne&#x2F;v2模块添加项目将 fyne.io&#x2F;fyne&#x2F;v2 这个 Go 模块的最新版本添加到你的项目中，并更新 go.mod 和 go.sum 文件以记录该依赖（运行完成之后自动生成go.mod 和 go.sum） 1go get fyne.io/fyne/v2@latest 4.清理和整理项目的依赖先不运行 1go mod tidy 5.案例一：一个带有窗口和标签的图形用户界面新建一个main.go文件 使用 Fyne 框架编写的简单 Go 应用程序作用是创建一个带有窗口和标签的图形用户界面 (GUI) 应用程序在main.go文件，输入 1234567891011121314package mainimport (\t&quot;fyne.io/fyne/v2/app&quot;\t&quot;fyne.io/fyne/v2/widget&quot;)func main() &#123;\ta := app.New()\tw := a.NewWindow(&quot;My application&quot;)// 创建一个新的窗口，并将窗口的标题设置为 &quot;My application&quot; 这个窗口是应用程序的主要界面，可以用来显示各种内容\tw.SetContent(widget.NewLabel(&quot;My application&quot;))// 设置窗口的内容为一个标签（Label）组件，标签文本为 &quot;My application&quot;\tw.ShowAndRun()&#125; go mod tidy一下再运行运行程序 1go run . 6.案例二：创建一个包含按钮的工具栏新建一个gui.go文件在gui.go中，输入 1234567891011121314151617181920212223package mainimport (\t&quot;fyne.io/fyne/v2&quot;\t&quot;fyne.io/fyne/v2/container&quot;\t&quot;fyne.io/fyne/v2/theme&quot;\t&quot;fyne.io/fyne/v2/widget&quot;)func makeGUI() fyne.CanvasObject &#123;\ttoolbar := widget.NewToolbar(// 创建一个工具栏（Toolbar），其中包含一个按钮（Action） widget.NewToolbarAction(theme.HomeIcon(), func() &#123;&#125;),// `widget.NewToolbarAction` 创建一个工具栏按钮，按钮的图标为 `theme.HomeIcon()`（房子图标）\t)// 第二个参数是按钮的点击事件，这里是一个空函数 `func() &#123;&#125;`，表示点击按钮时暂时不执行任何操作\tleft := widget.NewLabel(&quot;Left&quot;)// 创建一个标签（Label），显示 &quot;Left&quot;这个标签将被放置在窗口布局的左侧\tright := widget.NewLabel(&quot;Right&quot;)//标签将被放置在窗口布局的右侧\tcontent := widget.NewLabel(&quot;Content&quot;)//标签将被放置在窗口布局的中间 content.Alignment = fyne.TextAlignCenter// 设置标签组件（content）的文本对齐方式为居中对齐（TextAlignCenter）。fyne.TextAlignCenter 是 Fyne 提供的一个常量，用于指定文本在组件中的水平居中显示。\treturn container.NewBorder(toolbar, nil, left, right, content)// 使用 Border 布局创建一个容器（Container）`container.NewBorder` 接受五个参数，分别对应上、下、左、右和中间的组件&#125;// - `toolbar` 放置在顶部 `nil` 表示底部没有组件 `left` 放置在左侧 `right` 放置在右侧 `content` 放置在中间 修改main.go的第12行w.SetContent(widget.NewLabel(&quot;My application&quot;)) 1234567891011121314package mainimport (\t&quot;fyne.io/fyne/v2/app&quot;)func main() &#123;\ta := app.New()\tw := a.NewWindow(&quot;My application&quot;)// 创建一个新的窗口，并将窗口的标题设置为 &quot;My application&quot; 这个窗口是应用程序的主要界面，可以用来显示各种内容\tw.SetContent(makeGUI())//修改处 设置窗口的内容为 makeGUI() 函数返回的组件\tw.ShowAndRun()&#125; 运行程序 7.案例三：通过theme文件，调整字体大小main.go文件新增内容 1234567891011121314package mainimport (\t&quot;fyne.io/fyne/v2/app&quot;)func main() &#123;\ta := app.New() a.Settings().SetTheme(newFysionTheme())//新增内容\tw := a.NewWindow(&quot;My application&quot;)// 创建一个新的窗口，并将窗口的标题设置为 &quot;My application&quot; 这个窗口是应用程序的主要界面，可以用来显示各种内容\tw.SetContent(makeGUI())//修改处 设置窗口的内容为 makeGUI() 函数返回的组件\tw.ShowAndRun()&#125; 新建theme.go文件输入内容 12345678910111213141516171819202122232425262728293031package mainimport (\t&quot;image/color&quot; &quot;fyne.io/fyne/v2&quot; &quot;fyne.io/fyne/v2/theme&quot; )type fysionTheme struct &#123;// 定义一个自定义主题结构体 fysionTheme，嵌套 fyne.Theme 接口，用于扩展或自定义主题\tfyne.Theme&#125;func newFysionTheme() fyne.Theme &#123;// 定义一个函数 newFysionTheme，用于创建并返回一个自定义主题 fysionTheme\treturn &amp;fysionTheme&#123;Theme: theme.DefaultTheme()&#125; // 使用 Fyne 的默认主题作为基础主题&#125;func (t *fysionTheme) Color(name fyne.ThemeColorName, _ fyne.ThemeVariant) color.Color &#123;// 重写 fysionTheme 的 Color 方法，用于返回主题中的颜色\treturn t.Theme.Color(name, theme.VariantLight) // 始终返回浅色主题的颜色，不管当前主题模式为何&#125;func (t *fysionTheme) Size(name fyne.ThemeSizeName) float32 &#123;// 重写 fysionTheme 的 Size 方法，用于返回主题中的尺寸值\tif name == theme.SizeNameText &#123; // 请求的尺寸是文本字体大小 return 15 // 字体大小 返回固定值 15\t&#125;\treturn t.Theme.Size(name) // 对于其他尺寸，使用默认主题的尺寸值&#125; 运行程序 8.案例四：logo添加修改gui.go文件 123456789101112131415161718192021222324252627282930package mainimport (\t&quot;fyne.io/fyne/v2&quot;\t&quot;fyne.io/fyne/v2/container&quot;\t&quot;fyne.io/fyne/v2/theme&quot;\t&quot;fyne.io/fyne/v2/widget&quot;)func makeBanner() fyne.CanvasObject &#123;//新增内容 makeBanner makeBanner 创建一个横幅（Banner）区域，包含一个工具栏和一个图片。返回值为 fyne.CanvasObject 类型，可以直接作为 Fyne 的 UI 组件使用。\ttoolbor := widget.NewToolbar(// 创建工具栏 (Toolbar)，其中包含一个 Home 图标的按钮 widget.NewToolbarAction(theme.HomeIcon(), func() &#123;&#125;), // 点击按钮时，可以通过回调函数执行自定义逻辑（此处为空函数） )\tlogo := canvas.NewImageFromResource(resourceLogoPng)// 创建一个图片对象 (Image)，从资源文件中加载图片 resourceLogoPng 是通过 Fyne 的 bundle 工具生成的资源变量 logo.FillMode = canvas.ImageFillContain// 设置图片的填充模式为 ImageFillContain 这会保持图片的宽高比例并将其缩放到容器内。\treturn container.NewStack(toolbor, logo)// 将工具栏和图片叠加在一起，形成一个堆叠布局 (Stack Layout) 在堆叠布局中，组件会彼此重叠，后面的组件覆盖前面的组件。&#125;func makeGUI() fyne.CanvasObject &#123;\tleft := widget.NewLabel(&quot;Left&quot;)// 创建一个标签（Label），显示 &quot;Left&quot;这个标签将被放置在窗口布局的左侧\tright := widget.NewLabel(&quot;Right&quot;)//标签将被放置在窗口布局的右侧\tcontent := widget.NewLabel(&quot;Content&quot;)//标签将被放置在窗口布局的中间 content.Alignment = fyne.TextAlignCenter// 设置标签组件（content）的文本对齐方式为居中对齐（TextAlignCenter）。fyne.TextAlignCenter 是 Fyne 提供的一个常量，用于指定文本在组件中的水平居中显示。\treturn container.NewBorder(makeBanner(), nil, left, right, content)// 使用 Border 布局创建一个容器（Container）`container.NewBorder` 接受五个参数，分别对应上、下、左、右和中间的组件&#125;// toolbar改为`makeBanner(),` 放置在顶部 `nil` 表示底部没有组件 `left` 放置在左侧 `right` 放置在右侧 `content` 放置在中间 新建文件夹assets并在文件夹中存放logo.png 安装或更新 Fyne 框架提供的命令行工具 fyne并将其安装到 Go 的 GOPATH&#x2F;bin 目录中 1go install fyne.io/fyne/v2/cmd/fyne@latest 在theme.go文件中新增一行 1//go:generate fyne bundle -o bundled.go assets 生成bundle文件 1go generate 复制变量粘贴到gui.go中 运行程序 9.案例五：content区域填充灰色gui.go内容进行调整 1234567891011121314151617181920212223242526272829package mainimport (\t&quot;fyne.io/fyne/v2&quot;\t&quot;fyne.io/fyne/v2/container&quot;\t&quot;fyne.io/fyne/v2/theme&quot;\t&quot;fyne.io/fyne/v2/widget&quot;)func makeBanner() fyne.CanvasObject &#123;//新增内容 makeBanner makeBanner 创建一个横幅（Banner）区域，包含一个工具栏和一个图片。返回值为 fyne.CanvasObject 类型，可以直接作为 Fyne 的 UI 组件使用。\ttoolbor := widget.NewToolbar(// 创建工具栏 (Toolbar)，其中包含一个 Home 图标的按钮 widget.NewToolbarAction(theme.HomeIcon(), func() &#123;&#125;), // 点击按钮时，可以通过回调函数执行自定义逻辑（此处为空函数） )\tlogo := canvas.NewImageFromResource(resourceLogoPng)// 创建一个图片对象 (Image)，从资源文件中加载图片 resourceLogoPng 是通过 Fyne 的 bundle 工具生成的资源变量 logo.FillMode = canvas.ImageFillContain// 设置图片的填充模式为 ImageFillContain 这会保持图片的宽高比例并将其缩放到容器内。\treturn container.NewStack(toolbor, logo)// 将工具栏和图片叠加在一起，形成一个堆叠布局 (Stack Layout) 在堆叠布局中，组件会彼此重叠，后面的组件覆盖前面的组件。&#125;func makeGUI() fyne.CanvasObject &#123;\tleft := widget.NewLabel(&quot;Left&quot;)// 创建一个标签（Label），显示 &quot;Left&quot;这个标签将被放置在窗口布局的左侧\tright := widget.NewLabel(&quot;Right&quot;)//标签将被放置在窗口布局的右侧\tcontent := canvas.NewRectangle(color.Gray&#123;Y: 0xee&#125;)// 创建一个灰色的矩形对象 color.Gray&#123;Y: 0xee&#125; 表示一种灰色，其中 Y 的值范围是 0x00（黑色）到 0xff（白色）\treturn container.NewBorder(makeBanner(), nil, left, right, content)// 使用 Border 布局创建一个容器（Container）`container.NewBorder` 接受五个参数，分别对应上、下、左、右和中间的组件&#125;// `makeBanner(),` 放置在顶部 `nil` 表示底部没有组件 `left` 放置在左侧 `right` 放置在右侧 `content` 放置在中间 运行程序 10.案例六：返回布局尺寸新建layout.go文件输入内容 123456789101112131415161718192021222324package mainimport (\t&quot;log&quot;\t&quot;fyne.io/fyne/v2&quot;)type fysionLayout struct &#123;\ttop, left, right, content fyne.CanvasObject// 这些字段表示布局中的不同区域，每个区域都是 fyne.CanvasObject 类型的对象。&#125;func newFysionLayout(top, left, right, content fyne.CanvasObject) fyne.Layout &#123;// newFysionLayout 是一个构造函数，用于创建和初始化 fysionLayout 结构体\treturn &amp;fysionLayout&#123;top: top, left: left, right: right, content: content&#125;// 它接收四个 fyne.CanvasObject 参数，分别对应布局的顶部、左侧、右侧和内容区域&#125;// 返回值是一个实现了 fyne.Layout 接口的 fysionLayout 实例。func (l *fysionLayout) Layout(object []fyne.CanvasObject, size fyne.Size) &#123;// Layout 是 fysionLayout 结构体实现的 fyne.Layout 接口的一个方法\tlog.Println(&quot;size&quot;, size)// 该方法负责根据给定的容器大小 (size) 和子对象 (object) 来计算和设置每个子对象的位置和大小&#125;// 当前方法仅记录容器的大小 (size)，并未实际进行布局func (l *fysionLayout) MinSize(object []fyne.CanvasObject) fyne.Size &#123;// MinSize 该方法返回布局的最小尺寸 (fyne.Size)，即布局在其子对象完全可见的情况下所需的最小宽度和高度\treturn fyne.NewSize(50, 50)// 返回固定的最小尺寸&#125; 修改gui.go 12345678910111213141516171819202122232425262728293031package mainimport (\t&quot;fyne.io/fyne/v2&quot;\t&quot;fyne.io/fyne/v2/container&quot;\t&quot;fyne.io/fyne/v2/theme&quot;\t&quot;fyne.io/fyne/v2/widget&quot;)func makeBanner() fyne.CanvasObject &#123;//新增内容 makeBanner makeBanner 创建一个横幅（Banner）区域，包含一个工具栏和一个图片。返回值为 fyne.CanvasObject 类型，可以直接作为 Fyne 的 UI 组件使用。\ttoolbor := widget.NewToolbar(// 创建工具栏 (Toolbar)，其中包含一个 Home 图标的按钮 widget.NewToolbarAction(theme.HomeIcon(), func() &#123;&#125;), // 点击按钮时，可以通过回调函数执行自定义逻辑（此处为空函数） )\tlogo := canvas.NewImageFromResource(resourceLogoPng)// 创建一个图片对象 (Image)，从资源文件中加载图片 resourceLogoPng 是通过 Fyne 的 bundle 工具生成的资源变量 logo.FillMode = canvas.ImageFillContain// 设置图片的填充模式为 ImageFillContain 这会保持图片的宽高比例并将其缩放到容器内。\treturn container.NewStack(toolbor, logo)// 将工具栏和图片叠加在一起，形成一个堆叠布局 (Stack Layout) 在堆叠布局中，组件会彼此重叠，后面的组件覆盖前面的组件。&#125;func makeGUI() fyne.CanvasObject &#123;\ttop := makeBanner()// 调用 makeBanner() 函数创建一个顶部区域的组件并赋值给变量 top。\tleft := widget.NewLabel(&quot;Left&quot;)// 创建一个标签（Label），显示 &quot;Left&quot;这个标签将被放置在窗口布局的左侧\tright := widget.NewLabel(&quot;Right&quot;)//标签将被放置在窗口布局的右侧\tcontent := canvas.NewRectangle(color.Gray&#123;Y: 0xee&#125;)// 创建一个灰色的矩形对象 color.Gray&#123;Y: 0xee&#125; 表示一种灰色，其中 Y 的值范围是 0x00（黑色）到 0xff（白色） objs := []fyne.CanvasObject&#123;content, top, left, right&#125;//新增 return container.New(newFysionLayout(top, left, right, content), objs...)//修改// 使用 container.New 创建一个容器，并指定自定义布局管理器 newFysionLayout。&#125;// 第一个参数是自定义布局管理器，它负责定义子对象的排列方式。 第二个参数是 objs 切片，通过展开操作符 (objs...) 将所有子对象传递给容器。 运行程序拖拽到想要窗口大小在控制台中确定尺寸 11.案例七：区域的位置与大小的调整layout.go文件内容修改 12345678910111213141516171819202122232425262728293031323334package mainimport (\t&quot;fyne.io/fyne/v2&quot;)const sideWidth = 220//定义一个常量 sideWidth，表示侧边栏的宽度，单位为像素。type fysionLayout struct &#123;\ttop, left, right, content fyne.CanvasObject// 这些字段表示布局中的不同区域，每个区域都是 fyne.CanvasObject 类型的对象。&#125;func newFysionLayout(top, left, right, content fyne.CanvasObject) fyne.Layout &#123;// newFysionLayout 是一个构造函数，用于创建和初始化 fysionLayout 结构体\treturn &amp;fysionLayout&#123;top: top, left: left, right: right, content: content&#125;// 它接收四个 fyne.CanvasObject 参数，分别对应布局的顶部、左侧、右侧和内容区域&#125;// 返回值是一个实现了 fyne.Layout 接口的 fysionLayout 实例。func (l *fysionLayout) Layout(object []fyne.CanvasObject, size fyne.Size) &#123;// Layout 是 fysionLayout 结构体实现的 fyne.Layout 接口的一个方法\ttopHeight := l.top.MinSize().Height///获取顶部区域 (top) 的最小高度，确保顶部区域能够正确显示其内容。\tl.top.Resize(fyne.NewSize(size.Width, topHeight))// 调整顶部区域的大小，使其宽度与容器的宽度一致，高度为 topHeight。\tl.left.Move(fyne.NewPos(0, topHeight))// 调整左侧区域 (left) 的位置和大小。\tl.left.Resize(fyne.NewSize(sideWidth, size.Height-topHeight)) // 左侧区域的位置从容器的左上角 (0, topHeight) 开始，高度为容器高度减去顶部区域高度。\tl.right.Move(fyne.NewPos(size.Width-sideWidth, topHeight))//调整右侧区域 (right) 的位置和大小\tl.right.Resize(fyne.NewSize(sideWidth, size.Height-topHeight))// 右侧区域的位置从容器的右上角 (size.Width-sideWidth, topHeight) 开始，宽度为 sideWidth，高度与左侧区域相同\tl.content.Move(fyne.NewPos(sideWidth, topHeight))// 调整内容区域 (content) 的位置和大小。\tl.content.Resize(fyne.NewSize(size.Width-sideWidth*2, size.Height-topHeight)) // 内容区域位于左侧区域和右侧区域之间，其宽度为总宽度减去左右侧边栏的宽度，高度为容器高度减去顶部区域高度。&#125; func (l *fysionLayout) MinSize(object []fyne.CanvasObject) fyne.Size &#123;// MinSize 该方法返回布局的最小尺寸 (fyne.Size)，即布局在其子对象完全可见的情况下所需的最小宽度和高度\treturn fyne.NewSize(50, 50)// 返回固定的最小尺寸&#125; 运行程序left和right的宽度是固定的const sideWidth &#x3D; 220 12.案例八：初始窗口大小调整，使内容完全适配窗口gui.go内容修改 12345678910111213141516171819202122232425262728293031package mainimport (\t&quot;fyne.io/fyne/v2&quot;\t&quot;fyne.io/fyne/v2/container&quot;\t&quot;fyne.io/fyne/v2/theme&quot;\t&quot;fyne.io/fyne/v2/widget&quot;)func makeBanner() fyne.CanvasObject &#123;//新增内容 makeBanner makeBanner 创建一个横幅（Banner）区域，包含一个工具栏和一个图片。返回值为 fyne.CanvasObject 类型，可以直接作为 Fyne 的 UI 组件使用。\ttoolbor := widget.NewToolbar(// 创建工具栏 (Toolbar)，其中包含一个 Home 图标的按钮 widget.NewToolbarAction(theme.HomeIcon(), func() &#123;&#125;), // 点击按钮时，可以通过回调函数执行自定义逻辑（此处为空函数） )\tlogo := canvas.NewImageFromResource(resourceLogoPng)// 创建一个图片对象 (Image)，从资源文件中加载图片 resourceLogoPng 是通过 Fyne 的 bundle 工具生成的资源变量 logo.FillMode = canvas.ImageFillContain// 设置图片的填充模式为 ImageFillContain 这会保持图片的宽高比例并将其缩放到容器内。\treturn container.NewStack(toolbor, container.NewPadded(logo))// 将工具栏和图片叠加在一起，形成一个堆叠布局 (Stack Layout) &#125;//container.NewPadded 会将传入的组件（如 logo）包装在一个容器中，并为其四周添加均匀的内边距。这样可以使组件与周围的其他内容保持一定距离，从而提升视觉效果func makeGUI() fyne.CanvasObject &#123;\ttop := makeBanner()// 调用 makeBanner() 函数创建一个顶部区域的组件并赋值给变量 top。\tleft := widget.NewLabel(&quot;Left&quot;)// 创建一个标签（Label），显示 &quot;Left&quot;这个标签将被放置在窗口布局的左侧\tright := widget.NewLabel(&quot;Right&quot;)//标签将被放置在窗口布局的右侧\tcontent := canvas.NewRectangle(color.Gray&#123;Y: 0xee&#125;)// 创建一个灰色的矩形对象 color.Gray&#123;Y: 0xee&#125; 表示一种灰色，其中 Y 的值范围是 0x00（黑色）到 0xff（白色） objs := []fyne.CanvasObject&#123;content, top, left, right&#125;//新增 return container.New(newFysionLayout(top, left, right, content), objs...)//修改// 使用 container.New 创建一个容器，并指定自定义布局管理器 newFysionLayout。&#125;// 第一个参数是自定义布局管理器，它负责定义子对象的排列方式。 第二个参数是 objs 切片，通过展开操作符 (objs...) 将所有子对象传递给容器。 layout.go内容修改 1234567891011121314151617181920212223242526272829303132333435363738package mainimport (\t&quot;fyne.io/fyne/v2&quot;)const sideWidth = 220//定义一个常量 sideWidth，表示侧边栏的宽度，单位为像素。type fysionLayout struct &#123;\ttop, left, right, content fyne.CanvasObject// 这些字段表示布局中的不同区域，每个区域都是 fyne.CanvasObject 类型的对象。&#125;func newFysionLayout(top, left, right, content fyne.CanvasObject) fyne.Layout &#123;// newFysionLayout 是一个构造函数，用于创建和初始化 fysionLayout 结构体\treturn &amp;fysionLayout&#123;top: top, left: left, right: right, content: content&#125;// 它接收四个 fyne.CanvasObject 参数，分别对应布局的顶部、左侧、右侧和内容区域&#125;// 返回值是一个实现了 fyne.Layout 接口的 fysionLayout 实例。func (l *fysionLayout) Layout(object []fyne.CanvasObject, size fyne.Size) &#123;// Layout 是 fysionLayout 结构体实现的 fyne.Layout 接口的一个方法\ttopHeight := l.top.MinSize().Height///获取顶部区域 (top) 的最小高度，确保顶部区域能够正确显示其内容。\tl.top.Resize(fyne.NewSize(size.Width, topHeight))// 调整顶部区域的大小，使其宽度与容器的宽度一致，高度为 topHeight。\tl.left.Move(fyne.NewPos(0, topHeight))// 调整左侧区域 (left) 的位置和大小。\tl.left.Resize(fyne.NewSize(sideWidth, size.Height-topHeight)) // 左侧区域的位置从容器的左上角 (0, topHeight) 开始，高度为容器高度减去顶部区域高度。\tl.right.Move(fyne.NewPos(size.Width-sideWidth, topHeight))//调整右侧区域 (right) 的位置和大小\tl.right.Resize(fyne.NewSize(sideWidth, size.Height-topHeight))// 右侧区域的位置从容器的右上角 (size.Width-sideWidth, topHeight) 开始，宽度为 sideWidth，高度与左侧区域相同\tl.content.Move(fyne.NewPos(sideWidth, topHeight))// 调整内容区域 (content) 的位置和大小。\tl.content.Resize(fyne.NewSize(size.Width-sideWidth*2, size.Height-topHeight)) // 内容区域位于左侧区域和右侧区域之间，其宽度为总宽度减去左右侧边栏的宽度，高度为容器高度减去顶部区域高度。&#125; func (l *fysionLayout) MinSize(object []fyne.CanvasObject) fyne.Size &#123;// MinSize 该方法返回布局的最小尺寸 (fyne.Size)&#123; borders := fyne.NewSize(// 定义一个名为 borders 的变量，使用 fyne.NewSize 创建一个 Size 对象。 fyne.NewSize 用于表示一个二维尺寸，包含宽度和高度。 sideWidth*2,// 宽度为 sideWidth 的两倍，通常表示左右两边的宽度总和。 l.top.MinSize().Height,//// 高度为顶部区域 (l.top) 的最小高度，确保顶部区域内容能够正确显\t)\treturn borders.AddWidthHeight(100, 100)\t// 使用 borders 的 AddWidthHeight 方法，增加宽度和高度的值。&#125;// AddWidthHeight 是 fyne.Size 的方法，用于在现有尺寸的基础上增加指定的宽度和高度 这里将宽度和高度分别增加 100。 运行程序 13.案例九：将窗口大小设置为指定的宽度和高度将窗口大小设置为指定的宽度和高度（以像素为单位）main.go文件新增内容 123456789101112131415package mainimport (\t&quot;fyne.io/fyne/v2/app&quot;)func main() &#123;\ta := app.New() a.Settings().SetTheme(newFysionTheme())//新增内容\tw := a.NewWindow(&quot;My application&quot;)// 创建一个新的窗口，并将窗口的标题设置为 &quot;My application&quot; 这个窗口是应用程序的主要界面，可以用来显示各种内容 w.Resize(fyne.NewSize(1024, 768))//将窗口的尺寸调整为宽度 1024 像素，高度 768 像素\tw.SetContent(makeGUI())//修改处 设置窗口的内容为 makeGUI() 函数返回的组件\tw.ShowAndRun()&#125; 运行程序 14.案例十：分隔线的设置gui.go内容修改 12345678910111213141516171819202122232425262728293031323334353637package mainimport (\t&quot;image/color&quot;\t&quot;fyne.io/fyne/v2&quot;\t&quot;fyne.io/fyne/v2/canvas&quot;\t&quot;fyne.io/fyne/v2/container&quot;\t&quot;fyne.io/fyne/v2/theme&quot;\t&quot;fyne.io/fyne/v2/widget&quot;)func makeBanner() fyne.CanvasObject &#123;//新增内容 makeBanner makeBanner 创建一个横幅（Banner）区域，包含一个工具栏和一个图片。返回值为 fyne.CanvasObject 类型，可以直接作为 Fyne 的 UI 组件使用。\ttoolbor := widget.NewToolbar(// 创建工具栏 (Toolbar)，其中包含一个 Home 图标的按钮 widget.NewToolbarAction(theme.HomeIcon(), func() &#123;&#125;), // 点击按钮时，可以通过回调函数执行自定义逻辑（此处为空函数） )\tlogo := canvas.NewImageFromResource(resourceLogoPng)// 创建一个图片对象 (Image)，从资源文件中加载图片 resourceLogoPng 是通过 Fyne 的 bundle 工具生成的资源变量 logo.FillMode = canvas.ImageFillContain// 设置图片的填充模式为 ImageFillContain 这会保持图片的宽高比例并将其缩放到容器内。\treturn container.NewStack(toolbor, container.NewPadded(logo))// 将工具栏和图片叠加在一起，形成一个堆叠布局 (Stack Layout) &#125;//container.NewPadded 会将传入的组件（如 logo）包装在一个容器中，并为其四周添加均匀的内边距。这样可以使组件与周围的其他内容保持一定距离，从而提升视觉效果func makeGUI() fyne.CanvasObject &#123;\ttop := makeBanner()// 调用 makeBanner() 函数创建一个顶部区域的组件并赋值给变量 top。\tleft := widget.NewLabel(&quot;Left&quot;)// 创建一个标签（Label），显示 &quot;Left&quot;这个标签将被放置在窗口布局的左侧\tright := widget.NewLabel(&quot;Right&quot;)//标签将被放置在窗口布局的右侧\tcontent := canvas.NewRectangle(color.Gray&#123;Y: 0xee&#125;)// 创建一个灰色的矩形对象 color.Gray&#123;Y: 0xee&#125; 表示一种灰色，其中 Y 的值范围是 0x00（黑色）到 0xff（白色） dividers := [3]fyne.CanvasObject&#123; widget.NewSeparator(), widget.NewSeparator(), widget.NewSeparator(),// 定义分隔线数组，用于在布局中分隔不同部分\t&#125; objs := []fyne.CanvasObject&#123;content, top, left, right, dividers[0], dividers[1], dividers[2]&#125;// 定义CanvasObject 对象，用于传递给 container.New 内容区域(content)、顶部(top)、左侧(left)、右侧(right)，以及三个分隔线(dividers) return container.New(newFysionLayout(top, left, right, content, dividers), objs...)//修改// 使用 container.New 创建一个容器，并指定自定义布局管理器 newFysionLayout。&#125;// 第一个参数是自定义布局管理器，它负责定义子对象的排列方式。 第二个参数是 objs 切片，通过展开操作符 (objs...) 将所有子对象传递给容器。 在layout中新增内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package mainimport (\t&quot;fyne.io/fyne/v2&quot;\t&quot;fyne.io/fyne/v2/theme&quot;)const sideWidth = 220//定义一个常量 sideWidth，表示侧边栏的宽度，单位为像素。type fysionLayout struct &#123;\ttop, left, right, content fyne.CanvasObject// 这些字段表示布局中的不同区域，每个区域都是 fyne.CanvasObject 类型的对象。 dividers [3]fyne.CanvasObject&#125;func newFysionLayout(top, left, right, content fyne.CanvasObject, dividers [3]fyne.CanvasObject) fyne.Layout &#123;\treturn &amp;fysionLayout&#123;top: top, left: left, right: right, content: content, dividers: dividers&#125;&#125;func (l *fysionLayout) Layout(object []fyne.CanvasObject, size fyne.Size) &#123;// Layout 是 fysionLayout 结构体实现的 fyne.Layout 接口的一个方法\ttopHeight := l.top.MinSize().Height///获取顶部区域 (top) 的最小高度，确保顶部区域能够正确显示其内容。\tl.top.Resize(fyne.NewSize(size.Width, topHeight))// 调整顶部区域的大小，使其宽度与容器的宽度一致，高度为 topHeight。\tl.left.Move(fyne.NewPos(0, topHeight))// 调整左侧区域 (left) 的位置和大小。\tl.left.Resize(fyne.NewSize(sideWidth, size.Height-topHeight)) // 左侧区域的位置从容器的左上角 (0, topHeight) 开始，高度为容器高度减去顶部区域高度。\tl.right.Move(fyne.NewPos(size.Width-sideWidth, topHeight))//调整右侧区域 (right) 的位置和大小\tl.right.Resize(fyne.NewSize(sideWidth, size.Height-topHeight))// 右侧区域的位置从容器的右上角 (size.Width-sideWidth, topHeight) 开始，宽度为 sideWidth，高度与左侧区域相同\tl.content.Move(fyne.NewPos(sideWidth, topHeight))// 调整内容区域 (content) 的位置和大小。\tl.content.Resize(fyne.NewSize(size.Width-sideWidth*2, size.Height-topHeight)) // 内容区域位于左侧区域和右侧区域之间，其宽度为总宽度减去左右侧边栏的宽度，高度为容器高度减去顶部区域高度。 dividerThickness := theme.SeparatorThicknessSize()// 获取主题中分隔线的厚度 这行代码从主题中获取分隔线（Separator）的厚度值，通常用于设置分隔线的高度或宽度。\tl.dividers[0].Move(fyne.NewPos(0, topHeight))// 将第一个分隔线移动到 (0, topHeight) 的位置 位于窗口的顶部区域和内容区域的分界线处\tl.dividers[0].Resize(fyne.NewSize(size.Width, dividerThickness))// 设置第一个分隔线的大小：宽度为窗口的总宽度（size.Width），高度为分隔线的厚度（dividerThickness）。这使分隔线呈现为一条水平线，分隔顶部区域和其他内容。\tl.dividers[1].Move(fyne.NewPos(sideWidth, topHeight))// 将第二个分隔线移动到 (sideWidth, topHeight) 的位置 这里的 (sideWidth, topHeight) 表示分隔线的左上角坐标， 它位于左侧区域和内容区域的分界线处。\tl.dividers[1].Resize(fyne.NewSize(dividerThickness, size.Height-topHeight))// 设置第二个分隔线的大小：宽度为分隔线的厚度（dividerThickness），高度为从顶部到窗口底部的距离（size.Height - topHeight） 这使分隔线呈现为一条垂直线，分隔左侧区域和其他内容。\tl.dividers[2].Move(fyne.NewPos(size.Width-sideWidth, topHeight))//宽度为分隔线的厚度（dividerThickness），高度为从顶部到窗口底部的距离（size.Height - topHeight）\tl.dividers[2].Resize(fyne.NewSize(dividerThickness, size.Height-topHeight))//分隔线呈现为一条垂直线，分隔右侧内容区域和右侧边栏。&#125; func (l *fysionLayout) MinSize(object []fyne.CanvasObject) fyne.Size &#123;// MinSize 该方法返回布局的最小尺寸 (fyne.Size)&#123; borders := fyne.NewSize(// 定义一个名为 borders 的变量，使用 fyne.NewSize 创建一个 Size 对象。 fyne.NewSize 用于表示一个二维尺寸，包含宽度和高度。 sideWidth*2,// 宽度为 sideWidth 的两倍，通常表示左右两边的宽度总和。 l.top.MinSize().Height,//// 高度为顶部区域 (l.top) 的最小高度，确保顶部区域内容能够正确显\t)\treturn borders.AddWidthHeight(100, 100)\t// 使用 borders 的 AddWidthHeight 方法，增加宽度和高度的值。&#125;// AddWidthHeight 是 fyne.Size 的方法，用于在现有尺寸的基础上增加指定的宽度和高度 这里将宽度和高度分别增加 100。","categories":["AppBuilder"]},{"title":"hexo语言设置为中文","path":"/2025/03/19/4.hexo语言设置为中文/","content":"配置文件修改将language值改为zh","categories":["hexo使用教程"]},{"title":"stellar主题配置","path":"/2025/03/19/3.stellar主题配置/","content":"参考文章：https://xaoxuu.com/wiki/stellar/#start 1.下载主题github下载：https://github.com/xaoxuu/hexo-theme-stellar 或者使用命令行下载 1npm i hexo-theme-stellar 2.进行主题配置找到下载在themes中的文件 记住它的名字 打开_config.yml 找到theme:xxxxx，将xxxxx改为刚刚下载主题的名称 3.站点信息设置在_config.yml中修改站点信息 根据自己的需求对_config.yml进行修改 https://hexo.io/zh-cn/docs/configuration 4.创建主题配置文件在博客根目录的 _config.yml 文件旁边新建一个文件： _config.stellar.yml 在这个文件中的配置信息优先级高于主题文件夹中的配置文件 5.文章类型文章类型决定布局风格，有两种风格可选 tech: 默认技术类文章 story: 图文类文章，文字和段落间增距大 12article: type: tech # tech/story 6.文章封面在文章列表页面或者其他位置显示的文章摘要卡片上面的图片称之为「文章封面」 6.1 自动生成封面根据 tags 作为关键词为每一篇文章在线搜索封面： 12article: auto_cover: true 6.2 引用外部图片在文章的 front-matter 中写上 cover: xxx 即可。 123456blog/source/_posts/xxx.md---# 本地图片路径为 blog/source/assets/xaoxuu/blog/2020-0927a@1x.svg# 也可以直接引用图片直链 https://xxx.jpgcover: /assets/xaoxuu/blog/2020-0927a@1x.svg--- 上面这种方式会显示title与description或者摘要，若你想要图片全显示，可以加入如下参数： 123456789---cover: /assets/xaoxuu/blog/2020-0927a@1x.svg # 必选poster: # 海报（可选，全图封面卡片） topic: 标题上方的小字 # 可选 headline: 大标题 # 必选 caption: 标题下方的小字 # 可选 color: 标题颜色 # 可选，默认为跟随主题的动态颜色 # white,red...--- 效果图： 12345cover: github+hexo实现博客搭建/3448007-20250317193946584-1260067948.pngposter: # 海报（可选，全图封面卡片） headline: 上传博客到github caption: color: 标题颜色 # 可选，默认为跟随主题的动态颜色 # white,red... 7.文章模板使用 Hexo 自带模板实现命令行创建新文章时自动生成相关信息。 根目录下 scaffolds 文件夹中编辑 post.md 的 font-matter ，根据自己的需要增加想要配置的内容 123456789101112131415161718192021222324252627282930313233---# 基本信息title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags: []categories: []description: # excerpt 也可 # 封面cover: banner: poster: # 海报（可选，全图封面卡片） topic: 标题上方的小字 # 可选 headline: 大标题 # 必选 caption: 标题下方的小字 # 可选 color: 标题颜色 # 可选# 插件sticky: # 数字越大越靠前mermaid:katex: mathjax: # 可选topic: # 专栏 idauthor: references:comments: # 设置 false 禁止评论indexing: # 设置 false 避免被搜索breadcrumb: # 设置 false 隐藏面包屑导航leftbar: rightbar:h1: # 设置为 &#x27;&#x27; 隐藏标题type: # tech/story--- 8.文章分类123---categories: [设计开发, iOS开发]---","categories":["hexo使用教程"]},{"title":"上传博客到github命令","path":"/2025/03/18/2.上传博客到github命令/","content":"1.新建文章输入命令： 1hexo new “文章名称” 新建文章之后需要生成一遍文件输入命令： 1hexo g 2.部署到Github1hexo d","categories":["hexo使用教程"]},{"title":"github+hexo实现博客搭建","path":"/2025/03/18/1.github-hexo实现博客搭建/","content":"参考链接：https://blog.csdn.net/weixin_45377770/article/details/105228938 1.node.js下载https://nodejs.org/zh-cn/ 查看Node.js版本命令： 1node -v 2.git下载 查看Git版本命令 1git --version 3.注册Github账号以及建立仓库https://github.com/ 4.Create repository 用户名.github.io(这将是以后的访问域名) 先保存呆会儿要用 https://github.com/zzandmm/zzandmm.github.io.git 5.开始安装hexo1cnpm install -g hexo-cli 6.初始化Hexo1hexo init 7.设置ssh进入.ssh文件 1cd ~/.ssh 8.生成sshkey1ssh-keygen -t rsa -C ‘注册时的邮箱地址’ 9.github中输入key12lscat id_rsa.pub 点New SSH Key title可以随意 10.验证是否配置成功记得输入yes，这一步邮箱会收到邮件 1ssh -T git@github.com 11.绑定与Github的用户名和邮箱12git config --global user.name “注册时用户名”git config --global user.email “注册时邮箱” 12.修改config中的内容123456# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: git repo: git@github.com:zzandmm/zzandmm.github.io.git branch: master 13.安装上传工具1cnpm install hexo-deployer-git 14.新建一篇测试文章输入命令： 1hexo new “文章名称” 新建文章之后需要生成一遍文件输入命令： 1hexo g 15.部署到Github1hexo d","categories":["hexo使用教程"]},{"title":"生活的小插曲-钥匙","path":"/20.记录生活/1.某人忘带钥匙.html","content":"嘿，昨天，也就是周三 吃完饭，躺了一小会儿，计划逛盒马 结果怎么着，有人下楼，忘记带电瓶车钥匙 怎么办嘞，只能回去拿咯 嘿，这不是结束，而是开始 回去拿钥匙，顺便把忘带的垃圾带下来，还挺好的 当某人丢完垃圾，走向我的时候 某人笑着和我说，他忘带钥匙了 我以为他在开玩笑，没想到是真的， 某人再次回去 我心想这次总能带对吧 等呀等 终于某人带着钥匙下来 看着他的笑容，我总觉得不对劲 我试探的问，你拿的 该不会是我的钥匙吧 果然，还真的是我的钥匙 某人笑着递给我 又回去拿自己的 这一次，总算是拿对了 真的是好气又好笑","categories":[null]},{"title":"词句摘抄","path":"/20.记录生活/2.词句摘抄.html","content":"1.苍元图1我如终将升起的朝阳，谁也无法阻挡✅","categories":[null]},{"title":"1.github+hexo实现博客搭建","path":"/1.hexo使用教程/1.github-hexo实现博客搭建.html","content":"参考链接：https://blog.csdn.net/weixin_45377770/article/details/105228938 1.node.js下载https://nodejs.org/zh-cn/ 查看Node.js版本命令： 1node -v 2.git下载 查看Git版本命令 1git --version 3.注册Github账号以及建立仓库https://github.com/ 4.Create repository 用户名.github.io(这将是以后的访问域名) 先保存呆会儿要用 https://github.com/zzandmm/zzandmm.github.io.git 5.开始安装hexo1cnpm install -g hexo-cli 6.初始化Hexo1hexo init 7.设置ssh进入.ssh文件 1cd ~/.ssh 8.生成sshkey1ssh-keygen -t rsa -C ‘注册时的邮箱地址’ 9.github中输入key12lscat id_rsa.pub 点New SSH Key title可以随意 10.验证是否配置成功记得输入yes，这一步邮箱会收到邮件 1ssh -T git@github.com 11.绑定与Github的用户名和邮箱12git config --global user.name “注册时用户名”git config --global user.email “注册时邮箱” 12.修改config中的内容123456# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: git repo: git@github.com:zzandmm/zzandmm.github.io.git branch: master 13.安装上传工具1cnpm install hexo-deployer-git 14.新建一篇测试文章输入命令： 1hexo new “文章名称” 新建文章之后需要生成一遍文件输入命令： 1hexo g 15.部署到Github1hexo d","categories":[null]},{"title":"上传博客到github命令","path":"/1.hexo使用教程/2.上传博客到github命令.html","content":"1.新建文章输入命令： 1hexo new “文章名称” 新建文章之后需要生成一遍文件输入命令： 1hexo g 2.部署到Github1hexo d","categories":[null]},{"title":"文章封面及横幅","path":"/1.hexo使用教程/5.文章封面.html","content":"1.文章封面填写 topic 与 headline 时大标题位于上方 只填写 headline 或填写 headline 与 caption 时大标题位于下方 123456789---cover: /assets/xaoxuu/blog/2020-0927a@1x.svg # 必选poster: # 海报（可选，全图封面卡片） topic: 标题上方的小字 # 可选 headline: 大标题 # 必选 caption: 标题下方的小字 # 可选 color: 标题颜色 # 可选，默认为跟随主题的动态颜色 # white,red...--- 2.横幅123---banner: /assets/xaoxuu/blog/2020-0927a@1x.svg---","categories":[null]},{"title":"hexo语言设置为中文","path":"/1.hexo使用教程/4.hexo语言设置为中文.html","content":"配置文件修改将language值改为zh","categories":[null]},{"title":"Creating An App Builder","path":"/2.AppBuilder/1.Builder1.html","content":"1. 创建AppBuilder文件创建AppBuilder文件夹用于存放相关文件 我的AppBuilder所在位置 2.初始化go模块在终端，初始化一个 Go 模块，并创建一个名为 go.mod 的文件 （go.mod是运行后是自动生成的） 1go mod init appbuilder.app 3.将模块添加至项目将fyne.io&#x2F;fyne&#x2F;v2模块添加项目将 fyne.io&#x2F;fyne&#x2F;v2 这个 Go 模块的最新版本添加到你的项目中，并更新 go.mod 和 go.sum 文件以记录该依赖（运行完成之后自动生成go.mod 和 go.sum） 1go get fyne.io/fyne/v2@latest 4.清理和整理项目的依赖先不运行 1go mod tidy 5.案例一：一个带有窗口和标签的图形用户界面新建一个main.go文件 使用 Fyne 框架编写的简单 Go 应用程序作用是创建一个带有窗口和标签的图形用户界面 (GUI) 应用程序在main.go文件，输入 1234567891011121314package mainimport (\t&quot;fyne.io/fyne/v2/app&quot;\t&quot;fyne.io/fyne/v2/widget&quot;)func main() &#123;\ta := app.New()\tw := a.NewWindow(&quot;My application&quot;)// 创建一个新的窗口，并将窗口的标题设置为 &quot;My application&quot; 这个窗口是应用程序的主要界面，可以用来显示各种内容\tw.SetContent(widget.NewLabel(&quot;My application&quot;))// 设置窗口的内容为一个标签（Label）组件，标签文本为 &quot;My application&quot;\tw.ShowAndRun()&#125; go mod tidy一下再运行运行程序 1go run . 6.案例二：创建一个包含按钮的工具栏新建一个gui.go文件在gui.go中，输入 1234567891011121314151617181920212223package mainimport (\t&quot;fyne.io/fyne/v2&quot;\t&quot;fyne.io/fyne/v2/container&quot;\t&quot;fyne.io/fyne/v2/theme&quot;\t&quot;fyne.io/fyne/v2/widget&quot;)func makeGUI() fyne.CanvasObject &#123;\ttoolbar := widget.NewToolbar(// 创建一个工具栏（Toolbar），其中包含一个按钮（Action） widget.NewToolbarAction(theme.HomeIcon(), func() &#123;&#125;),// `widget.NewToolbarAction` 创建一个工具栏按钮，按钮的图标为 `theme.HomeIcon()`（房子图标）\t)// 第二个参数是按钮的点击事件，这里是一个空函数 `func() &#123;&#125;`，表示点击按钮时暂时不执行任何操作\tleft := widget.NewLabel(&quot;Left&quot;)// 创建一个标签（Label），显示 &quot;Left&quot;这个标签将被放置在窗口布局的左侧\tright := widget.NewLabel(&quot;Right&quot;)//标签将被放置在窗口布局的右侧\tcontent := widget.NewLabel(&quot;Content&quot;)//标签将被放置在窗口布局的中间 content.Alignment = fyne.TextAlignCenter// 设置标签组件（content）的文本对齐方式为居中对齐（TextAlignCenter）。fyne.TextAlignCenter 是 Fyne 提供的一个常量，用于指定文本在组件中的水平居中显示。\treturn container.NewBorder(toolbar, nil, left, right, content)// 使用 Border 布局创建一个容器（Container）`container.NewBorder` 接受五个参数，分别对应上、下、左、右和中间的组件&#125;// - `toolbar` 放置在顶部 `nil` 表示底部没有组件 `left` 放置在左侧 `right` 放置在右侧 `content` 放置在中间 修改main.go的第12行w.SetContent(widget.NewLabel(&quot;My application&quot;)) 1234567891011121314package mainimport (\t&quot;fyne.io/fyne/v2/app&quot;)func main() &#123;\ta := app.New()\tw := a.NewWindow(&quot;My application&quot;)// 创建一个新的窗口，并将窗口的标题设置为 &quot;My application&quot; 这个窗口是应用程序的主要界面，可以用来显示各种内容\tw.SetContent(makeGUI())//修改处 设置窗口的内容为 makeGUI() 函数返回的组件\tw.ShowAndRun()&#125; 运行程序 7.案例三：通过theme文件，调整字体大小main.go文件新增内容 1234567891011121314package mainimport (\t&quot;fyne.io/fyne/v2/app&quot;)func main() &#123;\ta := app.New() a.Settings().SetTheme(newFysionTheme())//新增内容\tw := a.NewWindow(&quot;My application&quot;)// 创建一个新的窗口，并将窗口的标题设置为 &quot;My application&quot; 这个窗口是应用程序的主要界面，可以用来显示各种内容\tw.SetContent(makeGUI())//修改处 设置窗口的内容为 makeGUI() 函数返回的组件\tw.ShowAndRun()&#125; 新建theme.go文件输入内容 12345678910111213141516171819202122232425262728293031package mainimport (\t&quot;image/color&quot; &quot;fyne.io/fyne/v2&quot; &quot;fyne.io/fyne/v2/theme&quot; )type fysionTheme struct &#123;// 定义一个自定义主题结构体 fysionTheme，嵌套 fyne.Theme 接口，用于扩展或自定义主题\tfyne.Theme&#125;func newFysionTheme() fyne.Theme &#123;// 定义一个函数 newFysionTheme，用于创建并返回一个自定义主题 fysionTheme\treturn &amp;fysionTheme&#123;Theme: theme.DefaultTheme()&#125; // 使用 Fyne 的默认主题作为基础主题&#125;func (t *fysionTheme) Color(name fyne.ThemeColorName, _ fyne.ThemeVariant) color.Color &#123;// 重写 fysionTheme 的 Color 方法，用于返回主题中的颜色\treturn t.Theme.Color(name, theme.VariantLight) // 始终返回浅色主题的颜色，不管当前主题模式为何&#125;func (t *fysionTheme) Size(name fyne.ThemeSizeName) float32 &#123;// 重写 fysionTheme 的 Size 方法，用于返回主题中的尺寸值\tif name == theme.SizeNameText &#123; // 请求的尺寸是文本字体大小 return 15 // 字体大小 返回固定值 15\t&#125;\treturn t.Theme.Size(name) // 对于其他尺寸，使用默认主题的尺寸值&#125; 运行程序 8.案例四：logo添加修改gui.go文件 123456789101112131415161718192021222324252627282930package mainimport (\t&quot;fyne.io/fyne/v2&quot;\t&quot;fyne.io/fyne/v2/container&quot;\t&quot;fyne.io/fyne/v2/theme&quot;\t&quot;fyne.io/fyne/v2/widget&quot;)func makeBanner() fyne.CanvasObject &#123;//新增内容 makeBanner makeBanner 创建一个横幅（Banner）区域，包含一个工具栏和一个图片。返回值为 fyne.CanvasObject 类型，可以直接作为 Fyne 的 UI 组件使用。\ttoolbor := widget.NewToolbar(// 创建工具栏 (Toolbar)，其中包含一个 Home 图标的按钮 widget.NewToolbarAction(theme.HomeIcon(), func() &#123;&#125;), // 点击按钮时，可以通过回调函数执行自定义逻辑（此处为空函数） )\tlogo := canvas.NewImageFromResource(resourceLogoPng)// 创建一个图片对象 (Image)，从资源文件中加载图片 resourceLogoPng 是通过 Fyne 的 bundle 工具生成的资源变量 logo.FillMode = canvas.ImageFillContain// 设置图片的填充模式为 ImageFillContain 这会保持图片的宽高比例并将其缩放到容器内。\treturn container.NewStack(toolbor, logo)// 将工具栏和图片叠加在一起，形成一个堆叠布局 (Stack Layout) 在堆叠布局中，组件会彼此重叠，后面的组件覆盖前面的组件。&#125;func makeGUI() fyne.CanvasObject &#123;\tleft := widget.NewLabel(&quot;Left&quot;)// 创建一个标签（Label），显示 &quot;Left&quot;这个标签将被放置在窗口布局的左侧\tright := widget.NewLabel(&quot;Right&quot;)//标签将被放置在窗口布局的右侧\tcontent := widget.NewLabel(&quot;Content&quot;)//标签将被放置在窗口布局的中间 content.Alignment = fyne.TextAlignCenter// 设置标签组件（content）的文本对齐方式为居中对齐（TextAlignCenter）。fyne.TextAlignCenter 是 Fyne 提供的一个常量，用于指定文本在组件中的水平居中显示。\treturn container.NewBorder(makeBanner(), nil, left, right, content)// 使用 Border 布局创建一个容器（Container）`container.NewBorder` 接受五个参数，分别对应上、下、左、右和中间的组件&#125;// toolbar改为`makeBanner(),` 放置在顶部 `nil` 表示底部没有组件 `left` 放置在左侧 `right` 放置在右侧 `content` 放置在中间 新建文件夹assets并在文件夹中存放logo.png 安装或更新 Fyne 框架提供的命令行工具 fyne并将其安装到 Go 的 GOPATH&#x2F;bin 目录中 1go install fyne.io/fyne/v2/cmd/fyne@latest 在theme.go文件中新增一行 1//go:generate fyne bundle -o bundled.go assets 生成bundle文件 1go generate 复制变量粘贴到gui.go中 运行程序 9.案例五：content区域填充灰色gui.go内容进行调整 1234567891011121314151617181920212223242526272829package mainimport (\t&quot;fyne.io/fyne/v2&quot;\t&quot;fyne.io/fyne/v2/container&quot;\t&quot;fyne.io/fyne/v2/theme&quot;\t&quot;fyne.io/fyne/v2/widget&quot;)func makeBanner() fyne.CanvasObject &#123;//新增内容 makeBanner makeBanner 创建一个横幅（Banner）区域，包含一个工具栏和一个图片。返回值为 fyne.CanvasObject 类型，可以直接作为 Fyne 的 UI 组件使用。\ttoolbor := widget.NewToolbar(// 创建工具栏 (Toolbar)，其中包含一个 Home 图标的按钮 widget.NewToolbarAction(theme.HomeIcon(), func() &#123;&#125;), // 点击按钮时，可以通过回调函数执行自定义逻辑（此处为空函数） )\tlogo := canvas.NewImageFromResource(resourceLogoPng)// 创建一个图片对象 (Image)，从资源文件中加载图片 resourceLogoPng 是通过 Fyne 的 bundle 工具生成的资源变量 logo.FillMode = canvas.ImageFillContain// 设置图片的填充模式为 ImageFillContain 这会保持图片的宽高比例并将其缩放到容器内。\treturn container.NewStack(toolbor, logo)// 将工具栏和图片叠加在一起，形成一个堆叠布局 (Stack Layout) 在堆叠布局中，组件会彼此重叠，后面的组件覆盖前面的组件。&#125;func makeGUI() fyne.CanvasObject &#123;\tleft := widget.NewLabel(&quot;Left&quot;)// 创建一个标签（Label），显示 &quot;Left&quot;这个标签将被放置在窗口布局的左侧\tright := widget.NewLabel(&quot;Right&quot;)//标签将被放置在窗口布局的右侧\tcontent := canvas.NewRectangle(color.Gray&#123;Y: 0xee&#125;)// 创建一个灰色的矩形对象 color.Gray&#123;Y: 0xee&#125; 表示一种灰色，其中 Y 的值范围是 0x00（黑色）到 0xff（白色）\treturn container.NewBorder(makeBanner(), nil, left, right, content)// 使用 Border 布局创建一个容器（Container）`container.NewBorder` 接受五个参数，分别对应上、下、左、右和中间的组件&#125;// `makeBanner(),` 放置在顶部 `nil` 表示底部没有组件 `left` 放置在左侧 `right` 放置在右侧 `content` 放置在中间 运行程序 10.案例六：返回布局尺寸新建layout.go文件输入内容 123456789101112131415161718192021222324package mainimport (\t&quot;log&quot;\t&quot;fyne.io/fyne/v2&quot;)type fysionLayout struct &#123;\ttop, left, right, content fyne.CanvasObject// 这些字段表示布局中的不同区域，每个区域都是 fyne.CanvasObject 类型的对象。&#125;func newFysionLayout(top, left, right, content fyne.CanvasObject) fyne.Layout &#123;// newFysionLayout 是一个构造函数，用于创建和初始化 fysionLayout 结构体\treturn &amp;fysionLayout&#123;top: top, left: left, right: right, content: content&#125;// 它接收四个 fyne.CanvasObject 参数，分别对应布局的顶部、左侧、右侧和内容区域&#125;// 返回值是一个实现了 fyne.Layout 接口的 fysionLayout 实例。func (l *fysionLayout) Layout(object []fyne.CanvasObject, size fyne.Size) &#123;// Layout 是 fysionLayout 结构体实现的 fyne.Layout 接口的一个方法\tlog.Println(&quot;size&quot;, size)// 该方法负责根据给定的容器大小 (size) 和子对象 (object) 来计算和设置每个子对象的位置和大小&#125;// 当前方法仅记录容器的大小 (size)，并未实际进行布局func (l *fysionLayout) MinSize(object []fyne.CanvasObject) fyne.Size &#123;// MinSize 该方法返回布局的最小尺寸 (fyne.Size)，即布局在其子对象完全可见的情况下所需的最小宽度和高度\treturn fyne.NewSize(50, 50)// 返回固定的最小尺寸&#125; 修改gui.go 12345678910111213141516171819202122232425262728293031package mainimport (\t&quot;fyne.io/fyne/v2&quot;\t&quot;fyne.io/fyne/v2/container&quot;\t&quot;fyne.io/fyne/v2/theme&quot;\t&quot;fyne.io/fyne/v2/widget&quot;)func makeBanner() fyne.CanvasObject &#123;//新增内容 makeBanner makeBanner 创建一个横幅（Banner）区域，包含一个工具栏和一个图片。返回值为 fyne.CanvasObject 类型，可以直接作为 Fyne 的 UI 组件使用。\ttoolbor := widget.NewToolbar(// 创建工具栏 (Toolbar)，其中包含一个 Home 图标的按钮 widget.NewToolbarAction(theme.HomeIcon(), func() &#123;&#125;), // 点击按钮时，可以通过回调函数执行自定义逻辑（此处为空函数） )\tlogo := canvas.NewImageFromResource(resourceLogoPng)// 创建一个图片对象 (Image)，从资源文件中加载图片 resourceLogoPng 是通过 Fyne 的 bundle 工具生成的资源变量 logo.FillMode = canvas.ImageFillContain// 设置图片的填充模式为 ImageFillContain 这会保持图片的宽高比例并将其缩放到容器内。\treturn container.NewStack(toolbor, logo)// 将工具栏和图片叠加在一起，形成一个堆叠布局 (Stack Layout) 在堆叠布局中，组件会彼此重叠，后面的组件覆盖前面的组件。&#125;func makeGUI() fyne.CanvasObject &#123;\ttop := makeBanner()// 调用 makeBanner() 函数创建一个顶部区域的组件并赋值给变量 top。\tleft := widget.NewLabel(&quot;Left&quot;)// 创建一个标签（Label），显示 &quot;Left&quot;这个标签将被放置在窗口布局的左侧\tright := widget.NewLabel(&quot;Right&quot;)//标签将被放置在窗口布局的右侧\tcontent := canvas.NewRectangle(color.Gray&#123;Y: 0xee&#125;)// 创建一个灰色的矩形对象 color.Gray&#123;Y: 0xee&#125; 表示一种灰色，其中 Y 的值范围是 0x00（黑色）到 0xff（白色） objs := []fyne.CanvasObject&#123;content, top, left, right&#125;//新增 return container.New(newFysionLayout(top, left, right, content), objs...)//修改// 使用 container.New 创建一个容器，并指定自定义布局管理器 newFysionLayout。&#125;// 第一个参数是自定义布局管理器，它负责定义子对象的排列方式。 第二个参数是 objs 切片，通过展开操作符 (objs...) 将所有子对象传递给容器。 运行程序拖拽到想要窗口大小在控制台中确定尺寸 11.案例七：区域的位置与大小的调整layout.go文件内容修改 12345678910111213141516171819202122232425262728293031323334package mainimport (\t&quot;fyne.io/fyne/v2&quot;)const sideWidth = 220//定义一个常量 sideWidth，表示侧边栏的宽度，单位为像素。type fysionLayout struct &#123;\ttop, left, right, content fyne.CanvasObject// 这些字段表示布局中的不同区域，每个区域都是 fyne.CanvasObject 类型的对象。&#125;func newFysionLayout(top, left, right, content fyne.CanvasObject) fyne.Layout &#123;// newFysionLayout 是一个构造函数，用于创建和初始化 fysionLayout 结构体\treturn &amp;fysionLayout&#123;top: top, left: left, right: right, content: content&#125;// 它接收四个 fyne.CanvasObject 参数，分别对应布局的顶部、左侧、右侧和内容区域&#125;// 返回值是一个实现了 fyne.Layout 接口的 fysionLayout 实例。func (l *fysionLayout) Layout(object []fyne.CanvasObject, size fyne.Size) &#123;// Layout 是 fysionLayout 结构体实现的 fyne.Layout 接口的一个方法\ttopHeight := l.top.MinSize().Height///获取顶部区域 (top) 的最小高度，确保顶部区域能够正确显示其内容。\tl.top.Resize(fyne.NewSize(size.Width, topHeight))// 调整顶部区域的大小，使其宽度与容器的宽度一致，高度为 topHeight。\tl.left.Move(fyne.NewPos(0, topHeight))// 调整左侧区域 (left) 的位置和大小。\tl.left.Resize(fyne.NewSize(sideWidth, size.Height-topHeight)) // 左侧区域的位置从容器的左上角 (0, topHeight) 开始，高度为容器高度减去顶部区域高度。\tl.right.Move(fyne.NewPos(size.Width-sideWidth, topHeight))//调整右侧区域 (right) 的位置和大小\tl.right.Resize(fyne.NewSize(sideWidth, size.Height-topHeight))// 右侧区域的位置从容器的右上角 (size.Width-sideWidth, topHeight) 开始，宽度为 sideWidth，高度与左侧区域相同\tl.content.Move(fyne.NewPos(sideWidth, topHeight))// 调整内容区域 (content) 的位置和大小。\tl.content.Resize(fyne.NewSize(size.Width-sideWidth*2, size.Height-topHeight)) // 内容区域位于左侧区域和右侧区域之间，其宽度为总宽度减去左右侧边栏的宽度，高度为容器高度减去顶部区域高度。&#125; func (l *fysionLayout) MinSize(object []fyne.CanvasObject) fyne.Size &#123;// MinSize 该方法返回布局的最小尺寸 (fyne.Size)，即布局在其子对象完全可见的情况下所需的最小宽度和高度\treturn fyne.NewSize(50, 50)// 返回固定的最小尺寸&#125; 运行程序left和right的宽度是固定的const sideWidth &#x3D; 220 12.案例八：初始窗口大小调整，使内容完全适配窗口gui.go内容修改 12345678910111213141516171819202122232425262728293031package mainimport (\t&quot;fyne.io/fyne/v2&quot;\t&quot;fyne.io/fyne/v2/container&quot;\t&quot;fyne.io/fyne/v2/theme&quot;\t&quot;fyne.io/fyne/v2/widget&quot;)func makeBanner() fyne.CanvasObject &#123;//新增内容 makeBanner makeBanner 创建一个横幅（Banner）区域，包含一个工具栏和一个图片。返回值为 fyne.CanvasObject 类型，可以直接作为 Fyne 的 UI 组件使用。\ttoolbor := widget.NewToolbar(// 创建工具栏 (Toolbar)，其中包含一个 Home 图标的按钮 widget.NewToolbarAction(theme.HomeIcon(), func() &#123;&#125;), // 点击按钮时，可以通过回调函数执行自定义逻辑（此处为空函数） )\tlogo := canvas.NewImageFromResource(resourceLogoPng)// 创建一个图片对象 (Image)，从资源文件中加载图片 resourceLogoPng 是通过 Fyne 的 bundle 工具生成的资源变量 logo.FillMode = canvas.ImageFillContain// 设置图片的填充模式为 ImageFillContain 这会保持图片的宽高比例并将其缩放到容器内。\treturn container.NewStack(toolbor, container.NewPadded(logo))// 将工具栏和图片叠加在一起，形成一个堆叠布局 (Stack Layout) &#125;//container.NewPadded 会将传入的组件（如 logo）包装在一个容器中，并为其四周添加均匀的内边距。这样可以使组件与周围的其他内容保持一定距离，从而提升视觉效果func makeGUI() fyne.CanvasObject &#123;\ttop := makeBanner()// 调用 makeBanner() 函数创建一个顶部区域的组件并赋值给变量 top。\tleft := widget.NewLabel(&quot;Left&quot;)// 创建一个标签（Label），显示 &quot;Left&quot;这个标签将被放置在窗口布局的左侧\tright := widget.NewLabel(&quot;Right&quot;)//标签将被放置在窗口布局的右侧\tcontent := canvas.NewRectangle(color.Gray&#123;Y: 0xee&#125;)// 创建一个灰色的矩形对象 color.Gray&#123;Y: 0xee&#125; 表示一种灰色，其中 Y 的值范围是 0x00（黑色）到 0xff（白色） objs := []fyne.CanvasObject&#123;content, top, left, right&#125;//新增 return container.New(newFysionLayout(top, left, right, content), objs...)//修改// 使用 container.New 创建一个容器，并指定自定义布局管理器 newFysionLayout。&#125;// 第一个参数是自定义布局管理器，它负责定义子对象的排列方式。 第二个参数是 objs 切片，通过展开操作符 (objs...) 将所有子对象传递给容器。 layout.go内容修改 1234567891011121314151617181920212223242526272829303132333435363738package mainimport (\t&quot;fyne.io/fyne/v2&quot;)const sideWidth = 220//定义一个常量 sideWidth，表示侧边栏的宽度，单位为像素。type fysionLayout struct &#123;\ttop, left, right, content fyne.CanvasObject// 这些字段表示布局中的不同区域，每个区域都是 fyne.CanvasObject 类型的对象。&#125;func newFysionLayout(top, left, right, content fyne.CanvasObject) fyne.Layout &#123;// newFysionLayout 是一个构造函数，用于创建和初始化 fysionLayout 结构体\treturn &amp;fysionLayout&#123;top: top, left: left, right: right, content: content&#125;// 它接收四个 fyne.CanvasObject 参数，分别对应布局的顶部、左侧、右侧和内容区域&#125;// 返回值是一个实现了 fyne.Layout 接口的 fysionLayout 实例。func (l *fysionLayout) Layout(object []fyne.CanvasObject, size fyne.Size) &#123;// Layout 是 fysionLayout 结构体实现的 fyne.Layout 接口的一个方法\ttopHeight := l.top.MinSize().Height///获取顶部区域 (top) 的最小高度，确保顶部区域能够正确显示其内容。\tl.top.Resize(fyne.NewSize(size.Width, topHeight))// 调整顶部区域的大小，使其宽度与容器的宽度一致，高度为 topHeight。\tl.left.Move(fyne.NewPos(0, topHeight))// 调整左侧区域 (left) 的位置和大小。\tl.left.Resize(fyne.NewSize(sideWidth, size.Height-topHeight)) // 左侧区域的位置从容器的左上角 (0, topHeight) 开始，高度为容器高度减去顶部区域高度。\tl.right.Move(fyne.NewPos(size.Width-sideWidth, topHeight))//调整右侧区域 (right) 的位置和大小\tl.right.Resize(fyne.NewSize(sideWidth, size.Height-topHeight))// 右侧区域的位置从容器的右上角 (size.Width-sideWidth, topHeight) 开始，宽度为 sideWidth，高度与左侧区域相同\tl.content.Move(fyne.NewPos(sideWidth, topHeight))// 调整内容区域 (content) 的位置和大小。\tl.content.Resize(fyne.NewSize(size.Width-sideWidth*2, size.Height-topHeight)) // 内容区域位于左侧区域和右侧区域之间，其宽度为总宽度减去左右侧边栏的宽度，高度为容器高度减去顶部区域高度。&#125; func (l *fysionLayout) MinSize(object []fyne.CanvasObject) fyne.Size &#123;// MinSize 该方法返回布局的最小尺寸 (fyne.Size)&#123; borders := fyne.NewSize(// 定义一个名为 borders 的变量，使用 fyne.NewSize 创建一个 Size 对象。 fyne.NewSize 用于表示一个二维尺寸，包含宽度和高度。 sideWidth*2,// 宽度为 sideWidth 的两倍，通常表示左右两边的宽度总和。 l.top.MinSize().Height,//// 高度为顶部区域 (l.top) 的最小高度，确保顶部区域内容能够正确显\t)\treturn borders.AddWidthHeight(100, 100)\t// 使用 borders 的 AddWidthHeight 方法，增加宽度和高度的值。&#125;// AddWidthHeight 是 fyne.Size 的方法，用于在现有尺寸的基础上增加指定的宽度和高度 这里将宽度和高度分别增加 100。 运行程序 13.案例九：将窗口大小设置为指定的宽度和高度将窗口大小设置为指定的宽度和高度（以像素为单位）main.go文件新增内容 123456789101112131415package mainimport (\t&quot;fyne.io/fyne/v2/app&quot;)func main() &#123;\ta := app.New() a.Settings().SetTheme(newFysionTheme())//新增内容\tw := a.NewWindow(&quot;My application&quot;)// 创建一个新的窗口，并将窗口的标题设置为 &quot;My application&quot; 这个窗口是应用程序的主要界面，可以用来显示各种内容 w.Resize(fyne.NewSize(1024, 768))//将窗口的尺寸调整为宽度 1024 像素，高度 768 像素\tw.SetContent(makeGUI())//修改处 设置窗口的内容为 makeGUI() 函数返回的组件\tw.ShowAndRun()&#125; 运行程序 14.案例十：分隔线的设置gui.go内容修改 12345678910111213141516171819202122232425262728293031323334353637package mainimport (\t&quot;image/color&quot;\t&quot;fyne.io/fyne/v2&quot;\t&quot;fyne.io/fyne/v2/canvas&quot;\t&quot;fyne.io/fyne/v2/container&quot;\t&quot;fyne.io/fyne/v2/theme&quot;\t&quot;fyne.io/fyne/v2/widget&quot;)func makeBanner() fyne.CanvasObject &#123;//新增内容 makeBanner makeBanner 创建一个横幅（Banner）区域，包含一个工具栏和一个图片。返回值为 fyne.CanvasObject 类型，可以直接作为 Fyne 的 UI 组件使用。\ttoolbor := widget.NewToolbar(// 创建工具栏 (Toolbar)，其中包含一个 Home 图标的按钮 widget.NewToolbarAction(theme.HomeIcon(), func() &#123;&#125;), // 点击按钮时，可以通过回调函数执行自定义逻辑（此处为空函数） )\tlogo := canvas.NewImageFromResource(resourceLogoPng)// 创建一个图片对象 (Image)，从资源文件中加载图片 resourceLogoPng 是通过 Fyne 的 bundle 工具生成的资源变量 logo.FillMode = canvas.ImageFillContain// 设置图片的填充模式为 ImageFillContain 这会保持图片的宽高比例并将其缩放到容器内。\treturn container.NewStack(toolbor, container.NewPadded(logo))// 将工具栏和图片叠加在一起，形成一个堆叠布局 (Stack Layout) &#125;//container.NewPadded 会将传入的组件（如 logo）包装在一个容器中，并为其四周添加均匀的内边距。这样可以使组件与周围的其他内容保持一定距离，从而提升视觉效果func makeGUI() fyne.CanvasObject &#123;\ttop := makeBanner()// 调用 makeBanner() 函数创建一个顶部区域的组件并赋值给变量 top。\tleft := widget.NewLabel(&quot;Left&quot;)// 创建一个标签（Label），显示 &quot;Left&quot;这个标签将被放置在窗口布局的左侧\tright := widget.NewLabel(&quot;Right&quot;)//标签将被放置在窗口布局的右侧\tcontent := canvas.NewRectangle(color.Gray&#123;Y: 0xee&#125;)// 创建一个灰色的矩形对象 color.Gray&#123;Y: 0xee&#125; 表示一种灰色，其中 Y 的值范围是 0x00（黑色）到 0xff（白色） dividers := [3]fyne.CanvasObject&#123; widget.NewSeparator(), widget.NewSeparator(), widget.NewSeparator(),// 定义分隔线数组，用于在布局中分隔不同部分\t&#125; objs := []fyne.CanvasObject&#123;content, top, left, right, dividers[0], dividers[1], dividers[2]&#125;// 定义CanvasObject 对象，用于传递给 container.New 内容区域(content)、顶部(top)、左侧(left)、右侧(right)，以及三个分隔线(dividers) return container.New(newFysionLayout(top, left, right, content, dividers), objs...)//修改// 使用 container.New 创建一个容器，并指定自定义布局管理器 newFysionLayout。&#125;// 第一个参数是自定义布局管理器，它负责定义子对象的排列方式。 第二个参数是 objs 切片，通过展开操作符 (objs...) 将所有子对象传递给容器。 在layout中新增内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package mainimport (\t&quot;fyne.io/fyne/v2&quot;\t&quot;fyne.io/fyne/v2/theme&quot;)const sideWidth = 220//定义一个常量 sideWidth，表示侧边栏的宽度，单位为像素。type fysionLayout struct &#123;\ttop, left, right, content fyne.CanvasObject// 这些字段表示布局中的不同区域，每个区域都是 fyne.CanvasObject 类型的对象。 dividers [3]fyne.CanvasObject&#125;func newFysionLayout(top, left, right, content fyne.CanvasObject, dividers [3]fyne.CanvasObject) fyne.Layout &#123;\treturn &amp;fysionLayout&#123;top: top, left: left, right: right, content: content, dividers: dividers&#125;&#125;func (l *fysionLayout) Layout(object []fyne.CanvasObject, size fyne.Size) &#123;// Layout 是 fysionLayout 结构体实现的 fyne.Layout 接口的一个方法\ttopHeight := l.top.MinSize().Height///获取顶部区域 (top) 的最小高度，确保顶部区域能够正确显示其内容。\tl.top.Resize(fyne.NewSize(size.Width, topHeight))// 调整顶部区域的大小，使其宽度与容器的宽度一致，高度为 topHeight。\tl.left.Move(fyne.NewPos(0, topHeight))// 调整左侧区域 (left) 的位置和大小。\tl.left.Resize(fyne.NewSize(sideWidth, size.Height-topHeight)) // 左侧区域的位置从容器的左上角 (0, topHeight) 开始，高度为容器高度减去顶部区域高度。\tl.right.Move(fyne.NewPos(size.Width-sideWidth, topHeight))//调整右侧区域 (right) 的位置和大小\tl.right.Resize(fyne.NewSize(sideWidth, size.Height-topHeight))// 右侧区域的位置从容器的右上角 (size.Width-sideWidth, topHeight) 开始，宽度为 sideWidth，高度与左侧区域相同\tl.content.Move(fyne.NewPos(sideWidth, topHeight))// 调整内容区域 (content) 的位置和大小。\tl.content.Resize(fyne.NewSize(size.Width-sideWidth*2, size.Height-topHeight)) // 内容区域位于左侧区域和右侧区域之间，其宽度为总宽度减去左右侧边栏的宽度，高度为容器高度减去顶部区域高度。 dividerThickness := theme.SeparatorThicknessSize()// 获取主题中分隔线的厚度 这行代码从主题中获取分隔线（Separator）的厚度值，通常用于设置分隔线的高度或宽度。\tl.dividers[0].Move(fyne.NewPos(0, topHeight))// 将第一个分隔线移动到 (0, topHeight) 的位置 位于窗口的顶部区域和内容区域的分界线处\tl.dividers[0].Resize(fyne.NewSize(size.Width, dividerThickness))// 设置第一个分隔线的大小：宽度为窗口的总宽度（size.Width），高度为分隔线的厚度（dividerThickness）。这使分隔线呈现为一条水平线，分隔顶部区域和其他内容。\tl.dividers[1].Move(fyne.NewPos(sideWidth, topHeight))// 将第二个分隔线移动到 (sideWidth, topHeight) 的位置 这里的 (sideWidth, topHeight) 表示分隔线的左上角坐标， 它位于左侧区域和内容区域的分界线处。\tl.dividers[1].Resize(fyne.NewSize(dividerThickness, size.Height-topHeight))// 设置第二个分隔线的大小：宽度为分隔线的厚度（dividerThickness），高度为从顶部到窗口底部的距离（size.Height - topHeight） 这使分隔线呈现为一条垂直线，分隔左侧区域和其他内容。\tl.dividers[2].Move(fyne.NewPos(size.Width-sideWidth, topHeight))//宽度为分隔线的厚度（dividerThickness），高度为从顶部到窗口底部的距离（size.Height - topHeight）\tl.dividers[2].Resize(fyne.NewSize(dividerThickness, size.Height-topHeight))//分隔线呈现为一条垂直线，分隔右侧内容区域和右侧边栏。&#125; func (l *fysionLayout) MinSize(object []fyne.CanvasObject) fyne.Size &#123;// MinSize 该方法返回布局的最小尺寸 (fyne.Size)&#123; borders := fyne.NewSize(// 定义一个名为 borders 的变量，使用 fyne.NewSize 创建一个 Size 对象。 fyne.NewSize 用于表示一个二维尺寸，包含宽度和高度。 sideWidth*2,// 宽度为 sideWidth 的两倍，通常表示左右两边的宽度总和。 l.top.MinSize().Height,//// 高度为顶部区域 (l.top) 的最小高度，确保顶部区域内容能够正确显\t)\treturn borders.AddWidthHeight(100, 100)\t// 使用 borders 的 AddWidthHeight 方法，增加宽度和高度的值。&#125;// AddWidthHeight 是 fyne.Size 的方法，用于在现有尺寸的基础上增加指定的宽度和高度 这里将宽度和高度分别增加 100。","categories":[null]},{"title":"Creating an App Builder 2","path":"/2.AppBuilder/2.Builder2.html","content":"在Creating an App Builder 1: Setup, layout and theme的基础上逐渐新增功能 1. 打包 Fyne 应用程序找一张png图片作为Icon 将 Fyne 应用程序打包在终端输入 1fyne package 查看打包的应用程序在终端输入 1open . 2.安装 Fyne 框架及其依赖项1fyne install 3.对 Fyne 应用程序进行配置新建FyneApp.toml文件FyneApp.toml 是 Fyne 应用程序的配置文件，通常用于定义应用程序的元数据和设置文件使用 TOML 格式，可以包含应用程序的名称、版本、图标路径等信息 将Icon移动到assets并在FyneApp.toml中输入 1234[Details] Icon = &quot;assets/Icon.png&quot; # 应用程序图标的路径 Name = &quot;My App&quot; # 应用程序的名称 ID = &quot;app.appbuilder&quot; # 应用程序的唯一标识符 终端输入命令，再次打包 1fyne package 终端输入命令 查看打包的程序 1open . 4.将 Fyne 应用程序打包为适用于 iOS 模拟器的可执行文件将 Fyne 应用程序打包为适用于 iOS 模拟器的可执行文件 拖入一张名为AppIcon.png图片作为app的图标 终端输入 1fyne package -os iossimulator 5.XCODE下载安装app store可以下载 下载好了之后需要添加账户，生成证书 IOS模拟器安装 安装完成之后可将 iOS 模拟器的可执行文件拖入iOS设备(图片建议是正方形的，非正方形会导致 可以用微信上传头像裁剪一下) 6.将 Fyne 应用程序打包为适用于 安卓 的可执行文件若要打包成安卓可执行文件（需要安装 Android NDK）输入以下命令，xxx替换成app的名称 1fyne package -os android -name xxxxxx -id com.example.xxxxxx 7.网页访问所写的程序终端输入 1fyne serve 终端输入http://localhost:8080/可访问 8.案例一：openProject方法 文件夹选择对话框openProject 方法用于打开一个文件夹选择对话框，允许用户选择一个目录 gui.go文件新增内容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package mainimport (\t&quot;image/color&quot;\t&quot;log&quot;\t&quot;fyne.io/fyne/v2&quot;\t&quot;fyne.io/fyne/v2/canvas&quot;\t&quot;fyne.io/fyne/v2/container&quot;\t&quot;fyne.io/fyne/v2/dialog&quot;\t&quot;fyne.io/fyne/v2/theme&quot;\t&quot;fyne.io/fyne/v2/widget&quot;)type gui struct &#123;\twin fyne.Window //// 定义一个窗口，类型为 fyne.Window&#125;func makeBanner() fyne.CanvasObject &#123;//新增内容 makeBanner makeBanner 创建一个横幅（Banner）区域，包含一个工具栏和一个图片。返回值为 fyne.CanvasObject 类型，可以直接作为 Fyne 的 UI 组件使用。\ttoolbor := widget.NewToolbar(// 创建工具栏 (Toolbar)，其中包含一个 Home 图标的按钮 widget.NewToolbarAction(theme.HomeIcon(), func() &#123;&#125;), // 点击按钮时，可以通过回调函数执行自定义逻辑（此处为空函数） )\tlogo := canvas.NewImageFromResource(resourceLogoPng)// 创建一个图片对象 (Image)，从资源文件中加载图片 resourceLogoPng 是通过 Fyne 的 bundle 工具生成的资源变量 logo.FillMode = canvas.ImageFillContain// 设置图片的填充模式为 ImageFillContain 这会保持图片的宽高比例并将其缩放到容器内。\treturn container.NewStack(toolbor, container.NewPadded(logo))// 将工具栏和图片叠加在一起，形成一个堆叠布局 (Stack Layout) &#125;//container.NewPadded 会将传入的组件（如 logo）包装在一个容器中，并为其四周添加均匀的内边距。这样可以使组件与周围的其他内容保持一定距离，从而提升视觉效果func (g *gui)makeGUI() fyne.CanvasObject &#123;//具有接收者 g *gui，这意味着它可以访问 gui 结构体中的其他字段和方法。\ttop := makeBanner()// 调用 makeBanner() 函数创建一个顶部区域的组件并赋值给变量 top。\tleft := widget.NewLabel(&quot;Left&quot;)// 创建一个标签（Label），显示 &quot;Left&quot;这个标签将被放置在窗口布局的左侧\tright := widget.NewLabel(&quot;Right&quot;)//标签将被放置在窗口布局的右侧\tcontent := canvas.NewRectangle(color.Gray&#123;Y: 0xee&#125;)// 创建一个灰色的矩形对象 color.Gray&#123;Y: 0xee&#125; 表示一种灰色，其中 Y 的值范围是 0x00（黑色）到 0xff（白色） dividers := [3]fyne.CanvasObject&#123; widget.NewSeparator(), widget.NewSeparator(), widget.NewSeparator(),// 定义分隔线数组，用于在布局中分隔不同部分\t&#125; objs := []fyne.CanvasObject&#123;content, top, left, right, dividers[0], dividers[1], dividers[2]&#125;// 定义CanvasObject 对象，用于传递给 container.New 内容区域(content)、顶部(top)、左侧(left)、右侧(right)，以及三个分隔线(dividers) return container.New(newFysionLayout(top, left, right, content, dividers), objs...)//修改// 使用 container.New 创建一个容器，并指定自定义布局管理器 newFysionLayout。&#125;// 第一个参数是自定义布局管理器，它负责定义子对象的排列方式。 第二个参数是 objs 切片，通过展开操作符 (objs...) 将所有子对象传递给容器。func (g *gui) openProject() &#123;// openProject 方法用于打开一个文件夹选择对话框，允许用户选择一个目录。\tdialog.ShowFolderOpen(func(dir fyne.ListableURI, err error) &#123;// 该回调函数在用户选择文件夹后被调用 这里可以添加处理用户选择的逻辑 dir: 用户选择的目录，类型为 fyne.ListableURI err: 如果选择过程中发生错误，将包含错误信息 log.Println(&quot;Dir opened&quot;, dir)// 记录打开的目录信息到日志 输出一条日志，内容为 &quot;Dir opened&quot; 和用户选择的目录 dir\t&#125;, g.win)&#125; main.go内容调整 12345678910111213141516171819package mainimport (\t&quot;fyne.io/fyne/v2/app&quot;)func main() &#123;\ta := app.New() a.Settings().SetTheme(newFysionTheme())//新增内容\tw := a.NewWindow(&quot;My application&quot;)// 创建一个新的窗口，并将窗口的标题设置为 &quot;My application&quot; 这个窗口是应用程序的主要界面，可以用来显示各种内容 w.SetPadded(false)// 设置窗口的填充属性为 false，表示不使用默认的边距 w.Resize(fyne.NewSize(1024, 768))//将窗口的尺寸调整为宽度 1024 像素，高度 768 像素 ui := &amp;gui&#123;win: w&#125; // 创建一个 gui 结构体实例，并将窗口对象传递给它\tw.SetContent(ui.makeGUI())// 设置窗口的内容为通过 ui.makeGUI() 创建的界面 ui.openProject()// 调用 openProject 方法以打开项目选择对话框\tw.ShowAndRun()// 显示窗口并进入应用程序的主事件循环&#125; 运行程序 9.案例二：在界面conent中动态更新目录信息gui.go内容调整 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package mainimport (\t&quot;image/color&quot;\t&quot;fyne.io/fyne/v2&quot;\t&quot;fyne.io/fyne/v2/canvas&quot;\t&quot;fyne.io/fyne/v2/container&quot;\t&quot;fyne.io/fyne/v2/dialog&quot;\t&quot;fyne.io/fyne/v2/theme&quot;\t&quot;fyne.io/fyne/v2/widget&quot;)type gui struct &#123;\twin fyne.Window // 定义一个窗口，类型为 fyne.Window\tdirectory *widget.Label// 用于显示当前选择的目录，类型为 *widget.Label，允许在界面中动态更新目录信息&#125;func makeBanner() fyne.CanvasObject &#123;//新增内容 makeBanner makeBanner 创建一个横幅（Banner）区域，包含一个工具栏和一个图片。返回值为 fyne.CanvasObject 类型，可以直接作为 Fyne 的 UI 组件使用。\ttoolbor := widget.NewToolbar(// 创建工具栏 (Toolbar)，其中包含一个 Home 图标的按钮 widget.NewToolbarAction(theme.HomeIcon(), func() &#123;&#125;), // 点击按钮时，可以通过回调函数执行自定义逻辑（此处为空函数） )\tlogo := canvas.NewImageFromResource(resourceLogoPng)// 创建一个图片对象 (Image)，从资源文件中加载图片 resourceLogoPng 是通过 Fyne 的 bundle 工具生成的资源变量 logo.FillMode = canvas.ImageFillContain// 设置图片的填充模式为 ImageFillContain 这会保持图片的宽高比例并将其缩放到容器内。\treturn container.NewStack(toolbor, container.NewPadded(logo))// 将工具栏和图片叠加在一起，形成一个堆叠布局 (Stack Layout) &#125;//container.NewPadded 会将传入的组件（如 logo）包装在一个容器中，并为其四周添加均匀的内边距。这样可以使组件与周围的其他内容保持一定距离，从而提升视觉效果func (g *gui)makeGUI() fyne.CanvasObject &#123;//具有接收者 g *gui，这意味着它可以访问 gui 结构体中的其他字段和方法。\ttop := makeBanner()// 调用 makeBanner() 函数创建一个顶部区域的组件并赋值给变量 top。\tleft := widget.NewLabel(&quot;Left&quot;)// 创建一个标签（Label），显示 &quot;Left&quot;这个标签将被放置在窗口布局的左侧\tright := widget.NewLabel(&quot;Right&quot;)//标签将被放置在窗口布局的右侧\tg.directory = widget.NewLabel(&quot;&quot;)// 创建一个新的标签，初始内容为空字符串，并将其赋值给 gui 结构体的 directory 字段\tcontent := container.NewStack(canvas.NewRectangle(color.Gray&#123;Y: 0xee&#125;), g.directory)// 创建一个新的堆叠容器，包含一个灰色矩形和目录标签 将之前创建的目录标签添加到堆叠容器中 dividers := [3]fyne.CanvasObject&#123; widget.NewSeparator(), widget.NewSeparator(), widget.NewSeparator(),// 定义分隔线数组，用于在布局中分隔不同部分\t&#125; objs := []fyne.CanvasObject&#123;content, top, left, right, dividers[0], dividers[1], dividers[2]&#125;// 定义CanvasObject 对象，用于传递给 container.New 内容区域(content)、顶部(top)、左侧(left)、右侧(right)，以及三个分隔线(dividers) return container.New(newFysionLayout(top, left, right, content, dividers), objs...)//修改// 使用 container.New 创建一个容器，并指定自定义布局管理器 newFysionLayout。&#125;// 第一个参数是自定义布局管理器，它负责定义子对象的排列方式。 第二个参数是 objs 切片，通过展开操作符 (objs...) 将所有子对象传递给容器。func (g *gui) openProject() &#123;// openProject 方法用于打开一个文件夹选择对话框，允许用户选择一个目录。\tdialog.ShowFolderOpen(func(dir fyne.ListableURI, err error) &#123;// 该回调函数在用户选择文件夹后被调用 这里可以添加处理用户选择的逻辑 dir: 用户选择的目录，类型为 fyne.ListableURI err: 如果选择过程中发生错误，将包含错误信息 if err != nil &#123; dialog.ShowError(err, g.win)// 检查是否发生错误 如果发生错误，显示错误对话框，并将错误信息和窗口传递给对话框 return &#125; if dir == nil &#123; return// 检查目录是否为 nil 如果目录为空，结束当前函数的执行 &#125; name := dir.Name()// 获取目录的名称 g.win.SetTitle(&quot;Fysion App: &quot; + name)// 设置窗口标题为 &quot;Fysion App: &quot; 加上目录名称 g.directory.SetText(name)// 更新显示的目录标签文本为目录名称\t&#125;, g.win)&#125; 运行程序 10.案例三：强制选择的对话框（不选择文件夹 无法关闭openfolder）gui.go内容修改 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package mainimport (\t&quot;image/color&quot;\t&quot;fyne.io/fyne/v2&quot;\t&quot;fyne.io/fyne/v2/canvas&quot;\t&quot;fyne.io/fyne/v2/container&quot;\t&quot;fyne.io/fyne/v2/dialog&quot;\t&quot;fyne.io/fyne/v2/theme&quot;\t&quot;fyne.io/fyne/v2/widget&quot;)type gui struct &#123;\twin fyne.Window // 定义一个窗口，类型为 fyne.Window\tdirectory *widget.Label// 用于显示当前选择的目录，类型为 *widget.Label，允许在界面中动态更新目录信息&#125;func makeBanner() fyne.CanvasObject &#123;//新增内容 makeBanner makeBanner 创建一个横幅（Banner）区域，包含一个工具栏和一个图片。返回值为 fyne.CanvasObject 类型，可以直接作为 Fyne 的 UI 组件使用。\ttoolbor := widget.NewToolbar(// 创建工具栏 (Toolbar)，其中包含一个 Home 图标的按钮 widget.NewToolbarAction(theme.HomeIcon(), func() &#123;&#125;), // 点击按钮时，可以通过回调函数执行自定义逻辑（此处为空函数） )\tlogo := canvas.NewImageFromResource(resourceLogoPng)// 创建一个图片对象 (Image)，从资源文件中加载图片 resourceLogoPng 是通过 Fyne 的 bundle 工具生成的资源变量 logo.FillMode = canvas.ImageFillContain// 设置图片的填充模式为 ImageFillContain 这会保持图片的宽高比例并将其缩放到容器内。\treturn container.NewStack(toolbor, container.NewPadded(logo))// 将工具栏和图片叠加在一起，形成一个堆叠布局 (Stack Layout) &#125;//container.NewPadded 会将传入的组件（如 logo）包装在一个容器中，并为其四周添加均匀的内边距。这样可以使组件与周围的其他内容保持一定距离，从而提升视觉效果func (g *gui)makeGUI() fyne.CanvasObject &#123;//具有接收者 g *gui，这意味着它可以访问 gui 结构体中的其他字段和方法。\ttop := makeBanner()// 调用 makeBanner() 函数创建一个顶部区域的组件并赋值给变量 top。\tleft := widget.NewLabel(&quot;Left&quot;)// 创建一个标签（Label），显示 &quot;Left&quot;这个标签将被放置在窗口布局的左侧\tright := widget.NewLabel(&quot;Right&quot;)//标签将被放置在窗口布局的右侧\tg.directory = widget.NewLabel(&quot;&quot;)// 创建一个新的标签，初始内容为空字符串，并将其赋值给 gui 结构体的 directory 字段\tcontent := container.NewStack(canvas.NewRectangle(color.Gray&#123;Y: 0xee&#125;), g.directory)// 创建一个新的堆叠容器，包含一个灰色矩形和目录标签 将之前创建的目录标签添加到堆叠容器中 dividers := [3]fyne.CanvasObject&#123; widget.NewSeparator(), widget.NewSeparator(), widget.NewSeparator(),// 定义分隔线数组，用于在布局中分隔不同部分\t&#125; objs := []fyne.CanvasObject&#123;content, top, left, right, dividers[0], dividers[1], dividers[2]&#125;// 定义CanvasObject 对象，用于传递给 container.New 内容区域(content)、顶部(top)、左侧(left)、右侧(right)，以及三个分隔线(dividers) return container.New(newFysionLayout(top, left, right, content, dividers), objs...)//修改// 使用 container.New 创建一个容器，并指定自定义布局管理器 newFysionLayout。&#125;// 第一个参数是自定义布局管理器，它负责定义子对象的排列方式。 第二个参数是 objs 切片，通过展开操作符 (objs...) 将所有子对象传递给容器。func (g *gui) openProject() &#123;// openProject 方法用于打开一个文件夹选择对话框，允许用户选择一个目录。\tdialog.ShowFolderOpen(func(dir fyne.ListableURI, err error) &#123;// 该回调函数在用户选择文件夹后被调用 这里可以添加处理用户选择的逻辑 dir: 用户选择的目录，类型为 fyne.ListableURI err: 如果选择过程中发生错误，将包含错误信息 if err != nil &#123; dialog.ShowError(err, g.win)// 检查是否发生错误 如果发生错误，显示错误对话框，并将错误信息和窗口传递给对话框 g.openProject()//打开openfolder return &#125; if dir == nil &#123; return// 检查目录是否为 nil 如果目录为空，结束当前函数的执行 &#125; name := dir.Name()// 获取目录的名称 g.win.SetTitle(&quot;Fysion App: &quot; + name)// 设置窗口标题为 &quot;Fysion App: &quot; 加上目录名称 g.directory.SetText(name)// 更新显示的目录标签文本为目录名称\t&#125;, g.win)&#125; 11.案例四：增加提示内容gui.go内容略作修改 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package mainimport (\t&quot;image/color&quot;\t&quot;fyne.io/fyne/v2&quot;\t&quot;fyne.io/fyne/v2/canvas&quot;\t&quot;fyne.io/fyne/v2/container&quot;\t&quot;fyne.io/fyne/v2/dialog&quot;\t&quot;fyne.io/fyne/v2/theme&quot;\t&quot;fyne.io/fyne/v2/widget&quot;)type gui struct &#123;\twin fyne.Window // 定义一个窗口，类型为 fyne.Window\tdirectory *widget.Label// 用于显示当前选择的目录，类型为 *widget.Label，允许在界面中动态更新目录信息&#125;func makeBanner() fyne.CanvasObject &#123;//新增内容 makeBanner makeBanner 创建一个横幅（Banner）区域，包含一个工具栏和一个图片。返回值为 fyne.CanvasObject 类型，可以直接作为 Fyne 的 UI 组件使用。\ttoolbor := widget.NewToolbar(// 创建工具栏 (Toolbar)，其中包含一个 Home 图标的按钮 widget.NewToolbarAction(theme.HomeIcon(), func() &#123;&#125;), // 点击按钮时，可以通过回调函数执行自定义逻辑（此处为空函数） )\tlogo := canvas.NewImageFromResource(resourceLogoPng)// 创建一个图片对象 (Image)，从资源文件中加载图片 resourceLogoPng 是通过 Fyne 的 bundle 工具生成的资源变量 logo.FillMode = canvas.ImageFillContain// 设置图片的填充模式为 ImageFillContain 这会保持图片的宽高比例并将其缩放到容器内。\treturn container.NewStack(toolbor, container.NewPadded(logo))// 将工具栏和图片叠加在一起，形成一个堆叠布局 (Stack Layout) &#125;//container.NewPadded 会将传入的组件（如 logo）包装在一个容器中，并为其四周添加均匀的内边距。这样可以使组件与周围的其他内容保持一定距离，从而提升视觉效果func (g *gui)makeGUI() fyne.CanvasObject &#123;//具有接收者 g *gui，这意味着它可以访问 gui 结构体中的其他字段和方法。\ttop := makeBanner()// 调用 makeBanner() 函数创建一个顶部区域的组件并赋值给变量 top。\tleft := widget.NewLabel(&quot;Left&quot;)// 创建一个标签（Label），显示 &quot;Left&quot;这个标签将被放置在窗口布局的左侧\tright := widget.NewLabel(&quot;Right&quot;)//标签将被放置在窗口布局的右侧\tg.directory = widget.NewLabel(&quot;Welcome to Fysion, open a folder... from the menu&quot;)// 创建一个新的标签，并将其赋值给 gui 结构体的 directory 字段\tcontent := container.NewStack(canvas.NewRectangle(color.Gray&#123;Y: 0xee&#125;), g.directory)// 创建一个新的堆叠容器，包含一个灰色矩形和目录标签 将之前创建的目录标签添加到堆叠容器中 dividers := [3]fyne.CanvasObject&#123; widget.NewSeparator(), widget.NewSeparator(), widget.NewSeparator(),// 定义分隔线数组，用于在布局中分隔不同部分\t&#125; objs := []fyne.CanvasObject&#123;content, top, left, right, dividers[0], dividers[1], dividers[2]&#125;// 定义CanvasObject 对象，用于传递给 container.New 内容区域(content)、顶部(top)、左侧(left)、右侧(right)，以及三个分隔线(dividers) return container.New(newFysionLayout(top, left, right, content, dividers), objs...)//修改// 使用 container.New 创建一个容器，并指定自定义布局管理器 newFysionLayout。&#125;// 第一个参数是自定义布局管理器，它负责定义子对象的排列方式。 第二个参数是 objs 切片，通过展开操作符 (objs...) 将所有子对象传递给容器。func (g *gui) openProject() &#123;// openProject 方法用于打开一个文件夹选择对话框，允许用户选择一个目录。\tdialog.ShowFolderOpen(func(dir fyne.ListableURI, err error) &#123;// 该回调函数在用户选择文件夹后被调用 这里可以添加处理用户选择的逻辑 dir: 用户选择的目录，类型为 fyne.ListableURI err: 如果选择过程中发生错误，将包含错误信息 if err != nil &#123; dialog.ShowError(err, g.win)// 检查是否发生错误 如果发生错误，显示错误对话框，并将错误信息和窗口传递给对话框 return &#125; if dir == nil &#123; return// 检查目录是否为 nil 如果目录为空，结束当前函数的执行 &#125; name := dir.Name()// 获取目录的名称 g.win.SetTitle(&quot;Fysion App: &quot; + name)// 设置窗口标题为 &quot;Fysion App: &quot; 加上目录名称 g.directory.SetText(name)// 更新显示的目录标签文本为目录名称\t&#125;, g.win)&#125; 运行程序 12.案例五：创建File菜单创建File菜单，可在File菜单中打开openflodermain.go新增内容 123456789101112131415161718192021222324252627282930package mainimport (\t&quot;fyne.io/fyne/v2/app&quot;)func main() &#123;\ta := app.New() a.Settings().SetTheme(newFysionTheme())//新增内容\tw := a.NewWindow(&quot;My application&quot;)// 创建一个新的窗口，并将窗口的标题设置为 &quot;My application&quot; 这个窗口是应用程序的主要界面，可以用来显示各种内容 w.SetPadded(false)// 设置窗口的填充属性为 false，表示不使用默认的边距 w.Resize(fyne.NewSize(1024, 768))//将窗口的尺寸调整为宽度 1024 像素，高度 768 像素 ui := &amp;gui&#123;win: w&#125; // 创建一个 gui 结构体实例，并将窗口对象传递给它\tw.SetContent(ui.makeGUI())// 设置窗口的内容为通过 ui.makeGUI() 创建的界面\tw.SetMainMenu(ui.makeMenu())// 将主菜单设置到窗口 w 中，ui 是一个包含 makeMenu 方法的结构体实例 ui.openProject()// 调用 openProject 方法以打开项目选择对话框\tw.ShowAndRun()// 显示窗口并进入应用程序的主事件循环 &#125;func (g *gui) makeMenu() *fyne.MainMenu &#123;// 定义一个名为 makeMenu 的方法，属于 gui 结构体，返回一个指向 fyne.MainMenu 的指针\tfile := fyne.NewMenu(&quot;File&quot;,// 创建一个名为 &quot;File&quot; 的菜单 fyne.NewMenuItem(&quot;Open Project&quot;, g.openProject),// 在 &quot;File&quot; 菜单中添加一个菜单项 &quot;Open Project&quot;，点击时调用 g.openProject 方法\t)\treturn fyne.NewMainMenu(file)// 返回一个新的主菜单，包含刚刚创建的 &quot;File&quot; 菜单&#125; 运行程序 13.案例六：窗口标题显示文件名称main.go新增内容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package main import ( &quot;flag&quot; &quot;fmt&quot; &quot;fyne.io/fyne/v2&quot; &quot;fyne.io/fyne/v2/app&quot; &quot;fyne.io/fyne/v2/storage&quot; )func main() &#123;\ta := app.New() a.Settings().SetTheme(newFysionTheme())//新增内容\tw := a.NewWindow(&quot;My application&quot;)// 创建一个新的窗口，并将窗口的标题设置为 &quot;My application&quot; 这个窗口是应用程序的主要界面，可以用来显示各种内容 w.SetPadded(false)// 设置窗口的填充属性为 false，表示不使用默认的边距 w.Resize(fyne.NewSize(1024, 768))//将窗口的尺寸调整为宽度 1024 像素，高度 768 像素 ui := &amp;gui&#123;win: w&#125; // 创建一个 gui 结构体实例，并将窗口对象传递给它\tw.SetContent(ui.makeGUI())// 设置窗口的内容为通过 ui.makeGUI() 创建的界面\tw.SetMainMenu(ui.makeMenu())// 将主菜单设置到窗口 w 中，ui 是一个包含 makeMenu 方法的结构体实例\tflag.Usage = func() &#123;// 设置 flag.Usage 函数，定义如何显示程序的使用说明 fmt.Println(&quot;Usage: fysion [project directory]&quot;)// 打印使用说明，提示用户输入项目目录\t&#125;\tflag.Parse()// 解析命令行参数\tif len(flag.Args()) &gt; 0 &#123;// 检查命令行参数的数量 dirPath := flag.Args()[0]// 获取第一个命令行参数，作为项目目录路径 dirURL := storage.NewFileURI(dirPath) // 创建一个新的文件 URI dir, err := storage.ListerForURI(dirURL)// 使用 ListerForURI 函数获取目录的列表器 if err != nil &#123; fmt.Println(&quot;Error opening project&quot;, err)// 如果发生错误，打印错误信息并返回 return &#125; else &#123; ui.openProject(dir) // 如果没有错误，调用 ui.openProject 方法打开项目 &#125; ui.openProjectDialog()// 打开项目对话框\t&#125;\tw.ShowAndRun()// 显示窗口并进入应用程序的主事件循环 &#125;func (g *gui) makeMenu() *fyne.MainMenu &#123;// 定义一个名为 makeMenu 的方法，属于 gui 结构体，返回一个指向 fyne.MainMenu 的指针\tfile := fyne.NewMenu(&quot;File&quot;,// 创建一个名为 &quot;File&quot; 的菜单 fyne.NewMenuItem(&quot;Open Project&quot;, g.openProjectDialog),// 在 &quot;File&quot; 菜单中添加一个菜单项 &quot;Open Project&quot;，点击时调用 g.openProjectDialog方法\t)\treturn fyne.NewMainMenu(file)// 返回一个新的主菜单，包含刚刚创建的 &quot;File&quot; 菜单&#125; gui.go文件修改 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package mainimport (\t&quot;image/color&quot;\t&quot;fyne.io/fyne/v2&quot;\t&quot;fyne.io/fyne/v2/canvas&quot;\t&quot;fyne.io/fyne/v2/container&quot;\t&quot;fyne.io/fyne/v2/dialog&quot;\t&quot;fyne.io/fyne/v2/theme&quot;\t&quot;fyne.io/fyne/v2/widget&quot;)type gui struct &#123;\twin fyne.Window // 定义一个窗口，类型为 fyne.Window\tdirectory *widget.Label// 用于显示当前选择的目录，类型为 *widget.Label，允许在界面中动态更新目录信息&#125;func makeBanner() fyne.CanvasObject &#123;//新增内容 makeBanner makeBanner 创建一个横幅（Banner）区域，包含一个工具栏和一个图片。返回值为 fyne.CanvasObject 类型，可以直接作为 Fyne 的 UI 组件使用。\ttoolbor := widget.NewToolbar(// 创建工具栏 (Toolbar)，其中包含一个 Home 图标的按钮 widget.NewToolbarAction(theme.HomeIcon(), func() &#123;&#125;), // 点击按钮时，可以通过回调函数执行自定义逻辑（此处为空函数） )\tlogo := canvas.NewImageFromResource(resourceLogoPng)// 创建一个图片对象 (Image)，从资源文件中加载图片 resourceLogoPng 是通过 Fyne 的 bundle 工具生成的资源变量 logo.FillMode = canvas.ImageFillContain// 设置图片的填充模式为 ImageFillContain 这会保持图片的宽高比例并将其缩放到容器内。\treturn container.NewStack(toolbor, container.NewPadded(logo))// 将工具栏和图片叠加在一起，形成一个堆叠布局 (Stack Layout) &#125;//container.NewPadded 会将传入的组件（如 logo）包装在一个容器中，并为其四周添加均匀的内边距。这样可以使组件与周围的其他内容保持一定距离，从而提升视觉效果func (g *gui)makeGUI() fyne.CanvasObject &#123;//具有接收者 g *gui，这意味着它可以访问 gui 结构体中的其他字段和方法。\ttop := makeBanner()// 调用 makeBanner() 函数创建一个顶部区域的组件并赋值给变量 top。\tleft := widget.NewLabel(&quot;Left&quot;)// 创建一个标签（Label），显示 &quot;Left&quot;这个标签将被放置在窗口布局的左侧\tright := widget.NewLabel(&quot;Right&quot;)//标签将被放置在窗口布局的右侧\tg.directory = widget.NewLabel(&quot;Welcome to Fysion, open a folder... from the menu&quot;)// 创建一个新的标签，并将其赋值给 gui 结构体的 directory 字段\tcontent := container.NewStack(canvas.NewRectangle(color.Gray&#123;Y: 0xee&#125;), g.directory)// 创建一个新的堆叠容器，包含一个灰色矩形和目录标签 将之前创建的目录标签添加到堆叠容器中 dividers := [3]fyne.CanvasObject&#123; widget.NewSeparator(), widget.NewSeparator(), widget.NewSeparator(),// 定义分隔线数组，用于在布局中分隔不同部分\t&#125; objs := []fyne.CanvasObject&#123;content, top, left, right, dividers[0], dividers[1], dividers[2]&#125;// 定义CanvasObject 对象，用于传递给 container.New 内容区域(content)、顶部(top)、左侧(left)、右侧(right)，以及三个分隔线(dividers) return container.New(newFysionLayout(top, left, right, content, dividers), objs...)//修改// 使用 container.New 创建一个容器，并指定自定义布局管理器 newFysionLayout。&#125;// 第一个参数是自定义布局管理器，它负责定义子对象的排列方式。 第二个参数是 objs 切片，通过展开操作符 (objs...) 将所有子对象传递给容器。func (g *gui) openProjectDialog() &#123;// openProjectDialog 方法属于 gui 结构体，用于打开一个文件夹选择对话框\tdialog.ShowFolderOpen(func(dir fyne.ListableURI, err error) &#123;// 该回调函数在用户选择文件夹后被调用 这里可以添加处理用户选择的逻辑 dir: 用户选择的目录，类型为 fyne.ListableURI err: 如果选择过程中发生错误，将包含错误信息 if err != nil &#123; dialog.ShowError(err, g.win)// 检查是否发生错误 如果发生错误，显示错误对话框，并将错误信息和窗口传递给对话框 return &#125; if dir == nil &#123; return// 检查目录是否为 nil 如果目录为空，结束当前函数的执行 &#125; g.openProject(dir)// 调用 openProject 方法，传入用户选择的目录\t&#125;, g.win)&#125;func (g *gui) openProject(dir fyne.ListableURI) &#123;// openProject 方法属于 gui 结构体，接收一个 ListableURI 类型的参数 dir\tname := dir.Name()// 获取目录的名称\tg.win.SetTitle(&quot;Fysion App: &quot; + name)// 设置窗口的标题，格式为 &quot;Fysion App: 项目名称&quot;\tg.directory.SetText(name)// 更新界面上显示的目录名称&#125; 运行程序.: 第一个点表示当前目录，Go 工具会在当前目录中查找 main 包并运行它。.: 第二个点也表示当前目录，作为命令行参数传递给程序。 1go run . . 14.案例七：取消自动打开foldermain.go文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package main import ( &quot;flag&quot; &quot;fmt&quot; &quot;fyne.io/fyne/v2&quot; &quot;fyne.io/fyne/v2/app&quot; &quot;fyne.io/fyne/v2/storage&quot; )func main() &#123;\ta := app.New() a.Settings().SetTheme(newFysionTheme())//新增内容\tw := a.NewWindow(&quot;My application&quot;)// 创建一个新的窗口，并将窗口的标题设置为 &quot;My application&quot; 这个窗口是应用程序的主要界面，可以用来显示各种内容 w.SetPadded(false)// 设置窗口的填充属性为 false，表示不使用默认的边距 w.Resize(fyne.NewSize(1024, 768))//将窗口的尺寸调整为宽度 1024 像素，高度 768 像素 ui := &amp;gui&#123;win: w&#125; // 创建一个 gui 结构体实例，并将窗口对象传递给它\tw.SetContent(ui.makeGUI())// 设置窗口的内容为通过 ui.makeGUI() 创建的界面\tw.SetMainMenu(ui.makeMenu())// 将主菜单设置到窗口 w 中，ui 是一个包含 makeMenu 方法的结构体实例\tflag.Usage = func() &#123;// 设置 flag.Usage 函数，定义如何显示程序的使用说明 fmt.Println(&quot;Usage: fysion [project directory]&quot;)// 打印使用说明，提示用户输入项目目录\t&#125;\tflag.Parse()// 解析命令行参数\tif len(flag.Args()) &gt; 0 &#123;// 检查命令行参数的数量 dirPath := flag.Args()[0]// 获取第一个命令行参数，作为项目目录路径 dirPath, err := filepath.Abs(dirPath)// 将 dirPath 转换为绝对路径 if err != nil &#123; fmt.Println(&quot;Error resolving project path&quot;, err)// 如果解析路径时发生错误，打印错误信息并终止程序 return &#125; dirURI := storage.NewFileURI(dirPath) // 创建一个新的文件 URI dir, err := storage.ListerForURI(dirURI)// 使用 ListerForURI 函数获取目录的列表器 if err != nil &#123; fmt.Println(&quot;Error opening project&quot;, err)// 如果发生错误，打印错误信息并返回 return &#125; ui.openProject(dir) &#125;else &#123; ui.openProjectDialog() &#125;\tw.ShowAndRun()// 显示窗口并进入应用程序的主事件循环&#125;func (g *gui) makeMenu() *fyne.MainMenu &#123;// 定义一个名为 makeMenu 的方法，属于 gui 结构体，返回一个指向 fyne.MainMenu 的指针\tfile := fyne.NewMenu(&quot;File&quot;,// 创建一个名为 &quot;File&quot; 的菜单 fyne.NewMenuItem(&quot;Open Project&quot;, g.openProjectDialog),// 在 &quot;File&quot; 菜单中添加一个菜单项 &quot;Open Project&quot;，点击时调用 g.openProjectDialog方法\t)\treturn fyne.NewMainMenu(file)// 返回一个新的主菜单，包含刚刚创建的 &quot;File&quot; 菜单&#125; 运行程序 1go run . . 15.案例八：标签内容自动更新gui.go内容修改 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package mainimport (\t&quot;image/color&quot;\t&quot;fyne.io/fyne/v2&quot;\t&quot;fyne.io/fyne/v2/canvas&quot;\t&quot;fyne.io/fyne/v2/container&quot;\t&quot;fyne.io/fyne/v2/data/binding&quot;\t&quot;fyne.io/fyne/v2/dialog&quot;\t&quot;fyne.io/fyne/v2/theme&quot;\t&quot;fyne.io/fyne/v2/widget&quot;)type gui struct &#123;\twin fyne.Window // 定义一个窗口，类型为 fyne.Window\ttitle binding.String//一个字符串类型的绑定对象&#125;func makeBanner() fyne.CanvasObject &#123;//新增内容 makeBanner makeBanner 创建一个横幅（Banner）区域，包含一个工具栏和一个图片。返回值为 fyne.CanvasObject 类型，可以直接作为 Fyne 的 UI 组件使用。\ttoolbor := widget.NewToolbar(// 创建工具栏 (Toolbar)，其中包含一个 Home 图标的按钮 widget.NewToolbarAction(theme.HomeIcon(), func() &#123;&#125;), // 点击按钮时，可以通过回调函数执行自定义逻辑（此处为空函数） )\tlogo := canvas.NewImageFromResource(resourceLogoPng)// 创建一个图片对象 (Image)，从资源文件中加载图片 resourceLogoPng 是通过 Fyne 的 bundle 工具生成的资源变量 logo.FillMode = canvas.ImageFillContain// 设置图片的填充模式为 ImageFillContain 这会保持图片的宽高比例并将其缩放到容器内。\treturn container.NewStack(toolbor, container.NewPadded(logo))// 将工具栏和图片叠加在一起，形成一个堆叠布局 (Stack Layout) &#125;//container.NewPadded 会将传入的组件（如 logo）包装在一个容器中，并为其四周添加均匀的内边距。这样可以使组件与周围的其他内容保持一定距离，从而提升视觉效果func (g *gui)makeGUI() fyne.CanvasObject &#123;//具有接收者 g *gui，这意味着它可以访问 gui 结构体中的其他字段和方法。\ttop := makeBanner()// 调用 makeBanner() 函数创建一个顶部区域的组件并赋值给变量 top。\tleft := widget.NewLabel(&quot;Left&quot;)// 创建一个标签（Label），显示 &quot;Left&quot;这个标签将被放置在窗口布局的左侧\tright := widget.NewLabel(&quot;Right&quot;)//标签将被放置在窗口布局的右侧\tdirectory := widget.NewLabelWithData(g.title)// 创建一个标签组件，并将其内容与 g.title 绑定。标签会动态显示 g.title 的值，当 g.title 更新时，标签内容会自动更新。\tcontent := container.NewStack(canvas.NewRectangle(color.Gray&#123;Y: 0xee&#125;), directory) dividers := [3]fyne.CanvasObject&#123; widget.NewSeparator(), widget.NewSeparator(), widget.NewSeparator(),// 定义分隔线数组，用于在布局中分隔不同部分\t&#125; objs := []fyne.CanvasObject&#123;content, top, left, right, dividers[0], dividers[1], dividers[2]&#125;// 定义CanvasObject 对象，用于传递给 container.New 内容区域(content)、顶部(top)、左侧(left)、右侧(right)，以及三个分隔线(dividers) return container.New(newFysionLayout(top, left, right, content, dividers), objs...)//修改// 使用 container.New 创建一个容器，并指定自定义布局管理器 newFysionLayout。&#125;// 第一个参数是自定义布局管理器，它负责定义子对象的排列方式。 第二个参数是 objs 切片，通过展开操作符 (objs...) 将所有子对象传递给容器。func (g *gui) openProjectDialog() &#123;// openProjectDialog 方法属于 gui 结构体，用于打开一个文件夹选择对话框\tdialog.ShowFolderOpen(func(dir fyne.ListableURI, err error) &#123;// 该回调函数在用户选择文件夹后被调用 这里可以添加处理用户选择的逻辑 dir: 用户选择的目录，类型为 fyne.ListableURI err: 如果选择过程中发生错误，将包含错误信息 if err != nil &#123; dialog.ShowError(err, g.win)// 检查是否发生错误 如果发生错误，显示错误对话框，并将错误信息和窗口传递给对话框 return &#125; if dir == nil &#123; return// 检查目录是否为 nil 如果目录为空，结束当前函数的执行 &#125; g.openProject(dir)// 调用 openProject 方法，传入用户选择的目录\t&#125;, g.win)&#125;func (g *gui) openProject(dir fyne.ListableURI) &#123;// openProject 方法属于 gui 结构体，接收一个 ListableURI 类型的参数 dir\tname := dir.Name()// 获取目录的名称\tg.win.SetTitle(&quot;Fysion App: &quot; + name)// 设置窗口的标题，格式为 &quot;Fysion App: 项目名称&quot;\tg.title.Set(name)// 将字符串变量 name 的值设置为绑定对象 g.title 的新值。 g.title 是一个 binding.String 类型的绑定对象，&#125;// 它与界面组件（如标签）绑定，值的变化会自动更新界面显示内容。 main.go内容修改 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package main import (\t&quot;flag&quot;\t&quot;fmt&quot;\t&quot;path/filepath&quot;\t&quot;fyne.io/fyne/v2&quot;\t&quot;fyne.io/fyne/v2/app&quot;\t&quot;fyne.io/fyne/v2/data/binding&quot;\t&quot;fyne.io/fyne/v2/storage&quot; )func main() &#123;\ta := app.New() a.Settings().SetTheme(newFysionTheme())//新增内容\tw := a.NewWindow(&quot;My application&quot;)// 创建一个新的窗口，并将窗口的标题设置为 &quot;My application&quot; 这个窗口是应用程序的主要界面，可以用来显示各种内容 w.SetPadded(false)// 设置窗口的填充属性为 false，表示不使用默认的边距 w.Resize(fyne.NewSize(1024, 768))//将窗口的尺寸调整为宽度 1024 像素，高度 768 像素\tui := &amp;gui&#123;win: w, title: binding.NewString()&#125;// 将窗口对象 w 赋值给 gui 的 win 字段 初始化 title 字段为一个可绑定的字符串对象。\tw.SetContent(ui.makeGUI())// 设置窗口的内容为通过 ui.makeGUI() 创建的界面\tw.SetMainMenu(ui.makeMenu())// 将主菜单设置到窗口 w 中，ui 是一个包含 makeMenu 方法的结构体实例\tflag.Usage = func() &#123;// 设置 flag.Usage 函数，定义如何显示程序的使用说明 fmt.Println(&quot;Usage: fysion [project directory]&quot;)// 打印使用说明，提示用户输入项目目录\t&#125;\tflag.Parse()// 解析命令行参数\tif len(flag.Args()) &gt; 0 &#123;// 检查命令行参数的数量 dirPath := flag.Args()[0]// 获取第一个命令行参数，作为项目目录路径 dirPath, err := filepath.Abs(dirPath)// 将 dirPath 转换为绝对路径 if err != nil &#123; fmt.Println(&quot;Error resolving project path&quot;, err)// 如果解析路径时发生错误，打印错误信息并终止程序 return &#125; dirURI := storage.NewFileURI(dirPath) // 创建一个新的文件 URI dir, err := storage.ListerForURI(dirURI)// 使用 ListerForURI 函数获取目录的列表器 if err != nil &#123; fmt.Println(&quot;Error opening project&quot;, err)// 如果发生错误，打印错误信息并返回 return &#125; ui.openProject(dir) &#125;else &#123; ui.openProjectDialog() // 调用 openProjectDialog 方法，弹出一个对话框让用户选择项目目录。 &#125;\tw.ShowAndRun()// 显示窗口并进入应用程序的主事件循环&#125;func (g *gui) makeMenu() *fyne.MainMenu &#123;// 定义一个名为 makeMenu 的方法，属于 gui 结构体，返回一个指向 fyne.MainMenu 的指针\tfile := fyne.NewMenu(&quot;File&quot;,// 创建一个名为 &quot;File&quot; 的菜单 fyne.NewMenuItem(&quot;Open Project&quot;, g.openProjectDialog),// 在 &quot;File&quot; 菜单中添加一个菜单项 &quot;Open Project&quot;，点击时调用 g.openProjectDialog方法\t)\treturn fyne.NewMainMenu(file)// 返回一个新的主菜单，包含刚刚创建的 &quot;File&quot; 菜单&#125; 运行程序 1go run . . 16.案例九：为绑定对象 ui.title 添加一个监听器（DataListener）gui.go内容调整 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package mainimport (\t&quot;image/color&quot;\t&quot;fyne.io/fyne/v2&quot;\t&quot;fyne.io/fyne/v2/canvas&quot;\t&quot;fyne.io/fyne/v2/container&quot;\t&quot;fyne.io/fyne/v2/data/binding&quot;\t&quot;fyne.io/fyne/v2/dialog&quot;\t&quot;fyne.io/fyne/v2/theme&quot;\t&quot;fyne.io/fyne/v2/widget&quot;)type gui struct &#123;\twin fyne.Window // 定义一个窗口，类型为 fyne.Window\ttitle binding.String//一个字符串类型的绑定对象&#125;func makeBanner() fyne.CanvasObject &#123;//新增内容 makeBanner makeBanner 创建一个横幅（Banner）区域，包含一个工具栏和一个图片。返回值为 fyne.CanvasObject 类型，可以直接作为 Fyne 的 UI 组件使用。\ttoolbor := widget.NewToolbar(// 创建工具栏 (Toolbar)，其中包含一个 Home 图标的按钮 widget.NewToolbarAction(theme.HomeIcon(), func() &#123;&#125;), // 点击按钮时，可以通过回调函数执行自定义逻辑（此处为空函数） )\tlogo := canvas.NewImageFromResource(resourceLogoPng)// 创建一个图片对象 (Image)，从资源文件中加载图片 resourceLogoPng 是通过 Fyne 的 bundle 工具生成的资源变量 logo.FillMode = canvas.ImageFillContain// 设置图片的填充模式为 ImageFillContain 这会保持图片的宽高比例并将其缩放到容器内。\treturn container.NewStack(toolbor, container.NewPadded(logo))// 将工具栏和图片叠加在一起，形成一个堆叠布局 (Stack Layout) &#125;//container.NewPadded 会将传入的组件（如 logo）包装在一个容器中，并为其四周添加均匀的内边距。这样可以使组件与周围的其他内容保持一定距离，从而提升视觉效果func (g *gui)makeGUI() fyne.CanvasObject &#123;//具有接收者 g *gui，这意味着它可以访问 gui 结构体中的其他字段和方法。\ttop := makeBanner()// 调用 makeBanner() 函数创建一个顶部区域的组件并赋值给变量 top。\tleft := widget.NewLabel(&quot;Left&quot;)// 创建一个标签（Label），显示 &quot;Left&quot;这个标签将被放置在窗口布局的左侧\tright := widget.NewLabel(&quot;Right&quot;)//标签将被放置在窗口布局的右侧\tdirectory := widget.NewLabelWithData(g.title)// 创建一个标签组件，并将其内容与 g.title 绑定。标签会动态显示 g.title 的值，当 g.title 更新时，标签内容会自动更新。\tcontent := container.NewStack(canvas.NewRectangle(color.Gray&#123;Y: 0xee&#125;), directory) dividers := [3]fyne.CanvasObject&#123; widget.NewSeparator(), widget.NewSeparator(), widget.NewSeparator(),// 定义分隔线数组，用于在布局中分隔不同部分\t&#125; objs := []fyne.CanvasObject&#123;content, top, left, right, dividers[0], dividers[1], dividers[2]&#125;// 定义CanvasObject 对象，用于传递给 container.New 内容区域(content)、顶部(top)、左侧(left)、右侧(right)，以及三个分隔线(dividers) return container.New(newFysionLayout(top, left, right, content, dividers), objs...)//修改// 使用 container.New 创建一个容器，并指定自定义布局管理器 newFysionLayout。&#125;// 第一个参数是自定义布局管理器，它负责定义子对象的排列方式。 第二个参数是 objs 切片，通过展开操作符 (objs...) 将所有子对象传递给容器。func (g *gui) makeMenu() *fyne.MainMenu &#123;// 定义一个名为 makeMenu 的方法，属于 gui 结构体，返回一个指向 fyne.MainMenu 的指针\tfile := fyne.NewMenu(&quot;File&quot;,// 创建一个名为 &quot;File&quot; 的菜单 fyne.NewMenuItem(&quot;Open Project&quot;, g.openProjectDialog),// 在 &quot;File&quot; 菜单中添加一个菜单项 &quot;Open Project&quot;，点击时调用 g.openProjectDialog方法\t)\treturn fyne.NewMainMenu(file)// 返回一个新的主菜单，包含刚刚创建的 &quot;File&quot; 菜单&#125;func (g *gui) openProjectDialog() &#123;// openProjectDialog 方法属于 gui 结构体，用于打开一个文件夹选择对话框\tdialog.ShowFolderOpen(func(dir fyne.ListableURI, err error) &#123;// 该回调函数在用户选择文件夹后被调用 这里可以添加处理用户选择的逻辑 dir: 用户选择的目录，类型为 fyne.ListableURI err: 如果选择过程中发生错误，将包含错误信息 if err != nil &#123; dialog.ShowError(err, g.win)// 检查是否发生错误 如果发生错误，显示错误对话框，并将错误信息和窗口传递给对话框 return &#125; if dir == nil &#123; return// 检查目录是否为 nil 如果目录为空，结束当前函数的执行 &#125; g.openProject(dir)// 调用 openProject 方法，传入用户选择的目录\t&#125;, g.win)&#125;func (g *gui) openProject(dir fyne.ListableURI) &#123;// openProject 方法属于 gui 结构体，接收一个 ListableURI 类型的参数 dir\tname := dir.Name()// 获取目录的名称\tg.title.Set(name)// 将字符串变量 name 的值设置为绑定对象 g.title 的新值。 g.title 是一个 binding.String 类型的绑定对象，&#125;// 它与界面组件（如标签）绑定，值的变化会自动更新界面显示内容。 main.go新增内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package main import (\t&quot;flag&quot;\t&quot;fmt&quot;\t&quot;path/filepath&quot;\t&quot;fyne.io/fyne/v2&quot;\t&quot;fyne.io/fyne/v2/app&quot;\t&quot;fyne.io/fyne/v2/data/binding&quot;\t&quot;fyne.io/fyne/v2/storage&quot; )func main() &#123;\ta := app.New() a.Settings().SetTheme(newFysionTheme())//新增内容\tw := a.NewWindow(&quot;My application&quot;)// 创建一个新的窗口，并将窗口的标题设置为 &quot;My application&quot; 这个窗口是应用程序的主要界面，可以用来显示各种内容 w.SetPadded(false)// 设置窗口的填充属性为 false，表示不使用默认的边距 w.Resize(fyne.NewSize(1024, 768))//将窗口的尺寸调整为宽度 1024 像素，高度 768 像素\tui := &amp;gui&#123;win: w, title: binding.NewString()&#125;// 将窗口对象 w 赋值给 gui 的 win 字段 初始化 title 字段为一个可绑定的字符串对象。\tw.SetContent(ui.makeGUI())// 设置窗口的内容为通过 ui.makeGUI() 创建的界面\tw.SetMainMenu(ui.makeMenu())// 将主菜单设置到窗口 w 中，ui 是一个包含 makeMenu 方法的结构体实例\tui.title.AddListener(binding.NewDataListener(func() &#123;// 为绑定对象 ui.title 添加一个监听器（DataListener） 当 ui.title 的值发生变化时，监听器会被触发，执行以下回调函数： name, _ := ui.title.Get() // 获取绑定对象 ui.title 的当前值。 w.SetTitle(&quot;Fysion App: &quot; + name) // 将窗口标题设置为 &quot;Fysion App: &quot; 加上绑定对象的值。\t&#125;))\tflag.Usage = func() &#123;// 设置 flag.Usage 函数，定义如何显示程序的使用说明 fmt.Println(&quot;Usage: fysion [project directory]&quot;)// 打印使用说明，提示用户输入项目目录\t&#125;\tflag.Parse()// 解析命令行参数\tif len(flag.Args()) &gt; 0 &#123;// 检查命令行参数的数量 dirPath := flag.Args()[0]// 获取第一个命令行参数，作为项目目录路径 dirPath, err := filepath.Abs(dirPath)// 将 dirPath 转换为绝对路径 if err != nil &#123; fmt.Println(&quot;Error resolving project path&quot;, err)// 如果解析路径时发生错误，打印错误信息并终止程序 return &#125; dirURI := storage.NewFileURI(dirPath) // 创建一个新的文件 URI dir, err := storage.ListerForURI(dirURI)// 使用 ListerForURI 函数获取目录的列表器 if err != nil &#123; fmt.Println(&quot;Error opening project&quot;, err)// 如果发生错误，打印错误信息并返回 return &#125; ui.openProject(dir) &#125;else &#123; ui.openProjectDialog() // 调用 openProjectDialog 方法，弹出一个对话框让用户选择项目目录。 &#125;\tw.ShowAndRun()// 显示窗口并进入应用程序的主事件循环&#125;","categories":[null]},{"title":"burp_并发插件","path":"/3.burp的使用/1.burp_并发插件.html","content":"1.插件安装下载 需要java环境 2.插件的使用抓到要并发的数据包右键发送到turbo intruder","categories":[null]},{"title":"burp_HaE插件安装","path":"/3.burp的使用/3.HaE插件安装.html","content":"1.下载地址https://github.com/gh0stkey/HaE 2.插件添加Extender - Extensions - Add - Select File - Next 2.配置文件存放地址 Linux&#x2F;Mac用户的配置文件目录：~/.config/HaE/ Windows用户的配置文件目录：%USERPROFILE%/.config/HaE/ 3.检查配置文件内容(添加插件的时候报错了 检查发现rules内容是空的)Rules.ymlhttps://github.com/gh0stkey/HaE/blob/master/src/main/resources/rules/Rules.yml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296rules:- group: Fingerprint rule: - name: Shiro loaded: true f_regex: (=deleteMe|rememberMe=) s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: green scope: any header engine: dfa sensitive: true - name: JSON Web Token loaded: true f_regex: (eyJ[A-Za-z0-9_-]&#123;10,&#125;\\.[A-Za-z0-9._-]&#123;10,&#125;|eyJ[A-Za-z0-9_\\/+-]&#123;10,&#125;\\.[A-Za-z0-9._\\/+-]&#123;10,&#125;) s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: green scope: any engine: nfa sensitive: true - name: Swagger UI loaded: true f_regex: ((swagger-ui.html)|(\\&quot;swagger\\&quot;:)|(Swagger UI)|(swaggerUi)|(swaggerVersion)) s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: red scope: response body engine: dfa sensitive: false - name: Ueditor loaded: true f_regex: (ueditor\\.(config|all)\\.js) s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: green scope: response body engine: dfa sensitive: false - name: Druid loaded: true f_regex: (Druid Stat Index) s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: orange scope: response body engine: dfa sensitive: false- group: Maybe Vulnerability rule: - name: Java Deserialization loaded: true f_regex: (javax\\.faces\\.ViewState) s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: yellow scope: response body engine: dfa sensitive: false - name: Debug Logic Parameters loaded: true f_regex: ((access=)|(adm=)|(admin=)|(alter=)|(cfg=)|(clone=)|(config=)|(create=)|(dbg=)|(debug=)|(delete=)|(disable=)|(edit=)|(enable=)|(exec=)|(execute=)|(grant=)|(load=)|(make=)|(modify=)|(rename=)|(reset=)|(root=)|(shell=)|(test=)|(toggl=)) s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: cyan scope: request engine: dfa sensitive: false - name: URL As A Value loaded: true f_regex: (=(https?)(://|%3a%2f%2f)) s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: cyan scope: any engine: nfa sensitive: false - name: Upload Form loaded: true f_regex: (type\\=\\&quot;file\\&quot;) s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: yellow scope: response body engine: dfa sensitive: false - name: DoS Paramters loaded: true f_regex: ((size=)|(page=)|(num=)|(limit=)|(start=)|(end=)|(count=)) s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: cyan scope: request engine: dfa sensitive: false- group: Basic Information rule: - name: Email loaded: true f_regex: (([a-z0-9]+[_|\\.])*[a-z0-9]+@([a-z0-9]+[-|_|\\.])*[a-z0-9]+\\.((?!js|css|jpg|jpeg|png|ico)[a-z]&#123;2,5&#125;)) s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: yellow scope: response engine: nfa sensitive: false - name: Chinese IDCard loaded: true f_regex: &#x27;[^0-9]((\\d&#123;8&#125;(0\\d|10|11|12)([0-2]\\d|30|31)\\d&#123;3&#125;$)|(\\d&#123;6&#125;(18|19|20)\\d&#123;2&#125;(0[1-9]|10|11|12)([0-2]\\d|30|31)\\d&#123;3&#125;(\\d|X|x)))[^0-9]&#x27; s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: orange scope: response body engine: nfa sensitive: true - name: Chinese Mobile Number loaded: true f_regex: &#x27;[^\\w]((?:(?:\\+|00)86)?1(?:(?:3[\\d])|(?:4[5-79])|(?:5[0-35-9])|(?:6[5-7])|(?:7[0-8])|(?:8[\\d])|(?:9[189]))\\d&#123;8&#125;)[^\\w]&#x27; s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: orange scope: response body engine: nfa sensitive: false - name: Internal IP Address loaded: true f_regex: &#x27;[^0-9]((127\\.0\\.0\\.1)|(10\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;)|(172\\.((1[6-9])|(2\\d)|(3[01]))\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;)|(192\\.168\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;))&#x27; s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: cyan scope: response engine: nfa sensitive: true - name: MAC Address loaded: true f_regex: (^([a-fA-F0-9]&#123;2&#125;(:[a-fA-F0-9]&#123;2&#125;)&#123;5&#125;)|[^a-zA-Z0-9]([a-fA-F0-9]&#123;2&#125;(:[a-fA-F0-9]&#123;2&#125;)&#123;5&#125;)) s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: green scope: response engine: nfa sensitive: true- group: Sensitive Information rule: - name: Cloud Key loaded: true f_regex: (((access)(|-|_)(key)(|-|_)(id|secret))|(LTAI[a-z0-9]&#123;12,20&#125;)) s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: yellow scope: any engine: nfa sensitive: false - name: Windows File/Dir Path loaded: true f_regex: &#x27;[^\\w](([a-zA-Z]:\\\\(?:\\w+\\\\?)*)|([a-zA-Z]:\\\\(?:\\w+\\\\)*\\w+\\.\\w+))&#x27; s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: green scope: response engine: nfa sensitive: true - name: Password Field loaded: true f_regex: ((|&#x27;|&quot;)(|[\\w]&#123;1,10&#125;)([p](ass|wd|asswd|assword))(|[\\w]&#123;1,10&#125;)(|&#x27;|&quot;)(:|=)( |)(&#x27;|&quot;)(.*?)(&#x27;|&quot;)(|,)) s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: yellow scope: response body engine: nfa sensitive: false - name: Username Field loaded: true f_regex: ((|&#x27;|&quot;)(|[\\w]&#123;1,10&#125;)(([u](ser|name|sername))|(account)|((((create|update)((d|r)|(by|on|at)))|(creator))))(|[\\w]&#123;1,10&#125;)(|&#x27;|&quot;)(:|=)( |)(&#x27;|&quot;)(.*?)(&#x27;|&quot;)(|,)) s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: green scope: response body engine: nfa sensitive: false - name: WeCom Key loaded: true f_regex: ((corp)(id|secret)) s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: green scope: response body engine: dfa sensitive: false - name: JDBC Connection loaded: true f_regex: (jdbc:[a-z:]+://[a-z0-9\\.\\-_:;=/@?,&amp;]+) s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: yellow scope: any engine: nfa sensitive: false - name: Authorization Header loaded: true f_regex: ((basic [a-z0-9=:_\\+\\/-]&#123;5,100&#125;)|(bearer [a-z0-9_.=:_\\+\\/-]&#123;5,100&#125;)) s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: yellow scope: response body engine: nfa sensitive: false - name: Sensitive Field loaded: true f_regex: ((\\[)?(&#x27;|&quot;)?([\\w]&#123;0,10&#125;)((key)|(secret)|(token)|(config)|(auth)|(access)|(admin))([\\w]&#123;0,10&#125;)(&#x27;|&quot;)?(\\])?( |)(:|=)( |)(&#x27;|&quot;)(.*?)(&#x27;|&quot;)(|,)) s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: yellow scope: response engine: nfa sensitive: false- group: New 0 rule: - name: New Name loaded: false f_regex: (First Regex) s_regex: (Second Regex) format: &#x27;&#123;0&#125;&#x27; color: gray scope: any engine: nfa sensitive: false- group: Other rule: - name: Linkfinder loaded: true f_regex: (?:&quot;|&#x27;)(((?:[a-zA-Z]&#123;1,10&#125;://|//)[^&quot;&#x27;/]&#123;1,&#125;\\.[a-zA-Z]&#123;2,&#125;[^&quot;&#x27;]&#123;0,&#125;)|((?:/|\\.\\./|\\./)[^&quot;&#x27;&gt;&lt;,;|*()(%%$^/\\\\\\[\\]][^&quot;&#x27;&gt;&lt;,;|()]&#123;1,&#125;)|([a-zA-Z0-9_\\-/]&#123;1,&#125;/[a-zA-Z0-9_\\-/]&#123;1,&#125;\\.(?:[a-zA-Z]&#123;1,4&#125;|action)(?:[\\?|#][^&quot;|&#x27;]&#123;0,&#125;|))|([a-zA-Z0-9_\\-/]&#123;1,&#125;/[a-zA-Z0-9_\\-/]&#123;3,&#125;(?:[\\?|#][^&quot;|&#x27;]&#123;0,&#125;|))|([a-zA-Z0-9_\\-]&#123;1,&#125;\\.(?:\\w)(?:[\\?|#][^&quot;|&#x27;]&#123;0,&#125;|)))(?:&quot;|&#x27;) s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: gray scope: response body engine: nfa sensitive: true - name: Source Map loaded: true f_regex: (\\.js\\.map) s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: pink scope: response body engine: dfa sensitive: false - name: HTML Notes loaded: true f_regex: (&lt;!--.*?--&gt;) s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: magenta scope: response body engine: nfa sensitive: false - name: Create Script loaded: true f_regex: (\\+\\&#123;.*?\\&#125;\\[[a-zA-Z]\\]\\+&quot;.*?\\.js&quot;) s_regex: &#x27;&quot;?([\\w].*?)&quot;?:&quot;(.*?)&quot;&#x27; format: &#x27;&#123;0&#125;.&#123;1&#125;&#x27; color: green scope: response body engine: nfa sensitive: false - name: URL Schemes loaded: true f_regex: ((?![http]|[https])(([-A-Za-z0-9]&#123;1,20&#125;)://[-A-Za-z0-9+&amp;@#/%?=~_|!:,.;]+[-A-Za-z0-9+&amp;@#/%=~_|])) s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: yellow scope: response body engine: nfa sensitive: false - name: Router Push loaded: true f_regex: (\\$router\\.push) s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: magenta scope: response body engine: dfa sensitive: false - name: All URL loaded: true f_regex: (https?://[-A-Za-z0-9+&amp;@#/%?=~_|!:,.;\\u4E00-\\u9FFF]+[-A-Za-z0-9+&amp;@#/%=~_|]) s_regex: &#x27;&#x27; format: &#x27;&#123;0&#125;&#x27; color: gray scope: response body engine: nfa sensitive: true Config.yml 123456excludeSuffix: 3g2|3gp|7z|aac|abw|aif|aifc|aiff|apk|arc|au|avi|azw|bat|bin|bmp|bz|bz2|cmd|cmx|cod|com|csh|css|csv|dll|doc|docx|ear|eot|epub|exe|flac|flv|gif|gz|ico|ics|ief|jar|jfif|jpe|jpeg|jpg|less|m3u|mid|midi|mjs|mkv|mov|mp2|mp3|mp4|mpa|mpe|mpeg|mpg|mpkg|mpp|mpv2|odp|ods|odt|oga|ogg|ogv|ogx|otf|pbm|pdf|pgm|png|pnm|ppm|ppt|pptx|ra|ram|rar|ras|rgb|rmi|rtf|scss|sh|snd|svg|swf|tar|tif|tiff|ttf|vsd|war|wav|weba|webm|webp|wmv|woff|woff2|xbm|xls|xlsx|xpm|xul|xwd|zipblockHost: gh0st.cnAIPrompt: |- You are a data security expert in the field of cyber security. Your task is to optimize the information provided by the user and then output it in JSON format. The user-supplied information is data that has been extracted by regular expressions. The user-supplied information is divided into two parts, the first part is RuleName which represents the name of the regular expression and the second part is MarkInfo which represents the data extracted by the regular expression. You need to find the matching or similar data in MarkInfo according to the meaning of RuleName, and output the original rows of these data in JSON format.(garbled and meaningless data rows should be removed) You must ensure that the extracted data is accurately expressed and correctly formatted in the JSON structure. Your output data must comply with the original MarkInfo content rows without modification, and strictly adhere to the following JSON format for return, no other text, code and formatting (e.g., line breaks, carriage returns, indentation, spaces), once the return of other irrelevant content will cause irreparable damage to the user: &#123;&quot;data&quot;:[&quot;data1&quot;, &quot;data2&quot;]&#125;.","categories":[null]},{"title":"浙江师范大学平台账户","path":"/30大学课程/1.浙江师范大学平台账户.html","content":"1.学习平台https://zsdxl.jxjy.chaoxing.com/loginuser_type=3账号：251113121061005密码：lxj123567 2.课程表 3.学习通 1","categories":[null]},{"title":"burp爆破时间调整","path":"/3.burp的使用/4.burp爆破时间调整.html","content":"","categories":[null]},{"title":"在burp中对字典进编码、解码","path":"/3.burp的使用/2.在burp中对字典进编码解码.html","content":"","categories":[null]},{"path":"/10.新东方SRC/1.新东方小书童APP/新东方小书童APP.html","content":"新东方小书童.APP"},{"title":"马克思主义基本原理","path":"/30大学课程/2.大学课程-马原/13.马克思主义基本原理.html","content":"1.导论导论1 什么是马克思马克思主义是由马克思和恩格斯创立并为后继者所不断发展的科学理论体系。 1.马克思主义基本原理是对马克思主义立场、观点、方法的集中概括，2.是马克思主义在其形成、发展和运用过程中经过反复检验而确立起来的具有普遍真理性的理论。3.它体现马克思主义的根本性质和整体特征，体现马克思主义科学性和革命性的统一。4.相对于特定历史条件下所做的个别理论判断和具体结论，马克思主义具有普遍的、根本的和长远的指导意义。 马克思主义的基本立场是马克思主义观察、分析和解决问题的根本立足和出发点。 马克思主义以无产阶级的解放和全人类的解放为己任，以人的自由全面发展为美好目标。 马克思的基本方法建立在辩证唯物主义和历史唯物主义的世界观和方法论基础上，指导我们正确认识世界和改造世界：实事求是的方法、辩证分析的方法、社会根本矛盾和主要矛盾分析的方法。 马克思主义的基本观点关于世界统一与物质、物质决定意识的观点关于事物矛盾运动规律的观点关于实践和认识辩证关系的观点关于社会存在决定社会意识的观点关于人与自然和谐共生的观点关于人类社会发展规律的观点关于世界历史的观点关于阶级和阶级斗争的观点关于人民群众创造历史的观点关于人的全面发展和社会全面进步的观点 关于商品经济和社会化大生产一般规律的观点关于劳动价值论、剩余价值论和资本主义生产方式的观点关于资本主义政治制度和意识形态本质的观点关于垄断资本主义的观点 关于社会主义必然代替资本主义的观点关于社会主义革命和无产阶级专政的观点关于社会主义社会本质特征和建设规律的观点关于共产主义社会基本特征和共产主义远大理想的观点 章节测验(多选题)马克思主义理论不可分割的三个主要组成部分是指（）。A、科学社会主义B、马克思主义哲学C、新自由主义D、马克思主义政治经济学 答案：ABD (多选题)马克思一生在理论上的两大发现包括（）。A、唯物史观B、唯心辩证法C、剩余价值学说D、空想社会主义 答案：AC (多选题)马克思主义的理论渊源主要有（）。A、英国古典政治经济学B、英国的不可知论思想C、德国古典哲学D、英法两国的空想社会主义 答案：ACD (判断题)马克思主义是指引人们创造美好生活的行动指南。 答案：对 (判断题)马克思主义以无产阶级的解放和全人类的解放为己任。 答案：对","categories":[null]},{"title":"创建专栏","path":"/1.hexo使用教程/6.创建专栏.html","content":"1.创建一个专栏在 blog/source/_data/ 文件夹中创建一个 topic 文件夹，在其中放入各个专栏的描述文件，文件名就是项目的 id： name值和id建议设置一样 1234name: Stellar # 在面包屑导航上会显示较短的名字title: Stellar - 每个人的独立博客 # 在列表页会显示完整的专栏标题description: 关于搭建独立博客相关的知识和经验分享，以及 Stellar 的高级用法、版本更新相关的注意事项。order_by: -date # 默认是按发布日期倒序排序 2. 发布文章在此专栏文章的 md 文件的 front-matter 部分指定所属的专栏 id （即上一步创建的文件名 id.yml） 12345678---title: 这是文章标题topic: id # 这是专栏id，对应 blog/source/_data/topic/id.yml---文章正文","categories":[null]}]